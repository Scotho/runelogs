{"version":3,"file":"static/js/220.02b6864c.chunk.js","mappings":"yCAEO,IAAKA,EAAQ,SAARA,GAAQ,OAARA,EAAQ,0BAARA,EAAQ,oCAARA,EAAQ,gCAARA,EAAQ,oCAARA,EAAQ,cAARA,EAAQ,8BAARA,EAAQ,gBAARA,CAAQ,MCFb,IAyBKC,EAAiB,SAAjBA,GAAiB,OAAjBA,EAAAA,EAAiB,wBAAjBA,EAAAA,EAAiB,0BAAjBA,EAAAA,EAAiB,oCAAjBA,EAAAA,EAAiB,wCAAjBA,EAAAA,EAAiB,wCAAjBA,EAAAA,EAAiB,sCAAjBA,EAAAA,EAAiB,0BAAjBA,CAAiB,MAUjBC,EAAoB,SAApBA,GAAoB,OAApBA,EAAAA,EAAoB,kCAApBA,EAAAA,EAAoB,4CAApBA,EAAAA,EAAoB,gDAApBA,EAAAA,EAAoB,gDAApBA,EAAAA,EAAoB,8CAApBA,CAAoB,MChCzB,SAASC,EAAiBC,GAC7B,MAAMC,EAA4BC,EAAuBF,GACnDG,EAAW,IAAIC,KAAKA,KAAKC,IAAI,EAAG,EAAG,EAAG,EAAG,EAAG,EAAGJ,IAC/CK,EAAUH,EAASI,gBACnBC,EAAUL,EAASM,gBACnBC,EAAeP,EAASQ,qBAG9B,MADuB,GAAAC,OAAMC,OAAOP,GAASQ,SAAS,EAAG,KAAI,KAAAF,OAAIC,OAAOL,GAASM,SAAS,EAAG,KAAI,KAAAF,OAAIF,EAEzG,CAEO,MAcMR,EAA0Ba,IACnC,GAA0B,IAAtBA,EAAMC,KAAKC,OACX,OAAO,EAGX,MAAMC,EAAYC,EAAoBJ,EAAMK,UAAUC,MAGtD,OAFgBF,EAAoBJ,EAAMO,SAASD,MAElCH,CAAS,EAYvB,MAAMC,EAAuBE,IAChC,MAAOE,EAAOjB,EAASE,GAAWa,EAAKG,MAAM,KAAKC,IAAIC,QAEtD,OAD6B,KAARH,EAA4B,IAAVjB,EAA4B,IAAVE,CACtC,EAGhB,SAASmB,EAAoBxB,GAChC,MAAMO,EAAekB,KAAKC,MAAM1B,EAAW,KAC3C,IAAIK,EAAeoB,KAAKC,MAAO1B,EAAW,IAAQ,IAC9CG,EAAesB,KAAKC,MAAO1B,EAAQ,IAAkB,IACrDoB,EAAaK,KAAKC,MAAO1B,EAAQ,KAAuB,IAE5DoB,EAASA,EAAQ,GAAM,IAAMA,EAAQA,EACrCjB,EAAWA,EAAU,GAAM,IAAMA,EAAUA,EAC3CE,EAAWA,EAAU,GAAM,IAAMA,EAAUA,EAI3C,OAAOe,EAAQ,IAAMjB,EAAU,IAAME,EAAU,KAFhBE,EAAe,GAAM,KAAOA,EAAgBA,EAAe,IAAO,IAAMA,EAAeA,EAG1H,C,uBC3DA,MAAMoB,EAAa,CACf,WACA,YACA,oBACA,mBACA,mBACA,MACA,iBACA,YACA,UACA,eACA,SACA,gBACA,oBACA,mBAMJ,SAASC,EAAqBC,GAC1B,OAAOC,OAAOC,OAAOrC,GAAmBsC,SAASH,EAAII,eACjDH,OAAOC,OAAOpC,GAAsBqC,SAASH,EAAII,eAC5B,aAArBJ,EAAII,YACZ,CC5BO,MAAMC,EAAgBC,IACzB,MAGMC,EAAmB,KACnBC,EAA2B,UAE3BC,EAAU,IAAIC,OAAO,KAAD9B,OANL,uBAMuB,OAAAA,OALvB,gCAKyC,OAAAA,OAJrC,OAI2D,QAAAA,OAAO2B,EAAgB,MAE3G,IAAII,EAAQL,EAAQK,MAAMF,GAE1B,IAAKE,EAED,OADAC,QAAQC,MAAM,2BAA4BP,GACnC,KAEX,MAAO,CAAEQ,EAAMzB,EAAM0B,EAAUC,GAAUL,EAGnCM,EAAoB,IAAIP,OAAO,gBAAD9B,OAAiB2B,EAAgB,MAErE,GADAI,EAAQK,EAAOL,MAAMM,GACjBN,EAAO,CACP,MAAO,CAAEO,GAAcP,EAEvB,OADAC,QAAQZ,IAAI,eAADpB,OAAgBsC,IACpB,CACHC,KAAMvD,EAASwD,YACfN,OACAzB,OACA0B,WACAG,aAER,CACA,MAAMG,EAAwB,IAAIX,OAAO,wBAAD9B,OAAyB2B,EAAgB,MAEjF,GADAI,EAAQK,EAAOL,MAAMU,GACjBV,EAAO,CACP,MAAO,CAAEW,GAAkBX,EAC3B,MAAO,CACHQ,KAAMvD,EAAS2D,iBACfT,OACAzB,OACA0B,WACAO,iBAER,CAEA,MAAME,EAAuB,IAAId,OAAO,mFAExC,GADAC,EAAQK,EAAOL,MAAMa,GACjBb,EAAO,CACP,MAAO,CAAEc,EAAQC,EAAUC,EAASC,EAAQC,EAAOC,EAAWC,GAAUpB,EAAMlB,IAAIC,QAElF,MAAO,CACHyB,KAAMvD,EAASoE,eACflB,OACAzB,OACA0B,WACAkB,cAAe,CACXR,SACAC,WACAC,UACAC,SACAC,QACAC,YACAC,UAGZ,CAEA,MAAMG,EAAyB,IAAIxB,OAAO,wBAAD9B,OAAyB2B,EAAgB,MAElF,GADAI,EAAQK,EAAOL,MAAMuB,GACjBvB,EAAO,CACP,MAAO,CAAEwB,GAAmBxB,EACtByB,EAA4BC,KAAKC,MAAMH,GAAiB1C,KAAK8C,GAAiBA,EAAKC,aACzF,MAAO,CACHrB,KAAMvD,EAAS6E,iBACf3B,OACAzB,OACA0B,WACAqB,kBAER,CAEA,MAAMM,EAAc,IAAIhC,OAAO,KAAD9B,OAAM2B,EAAgB,WAEpD,GADAI,EAAQK,EAAOL,MAAM+B,GACjB/B,EAAO,CACP,MAAO,CAAEgC,GAAUhC,EACnB,MAAO,CACHQ,KAAMvD,EAASgF,MACf9B,OACAzB,OACA0B,WACA4B,SAER,CAEA,MAAME,EAAuB,IAAInC,OAAO,KAAD9B,OAAM2B,EAAgB,yBAAA3B,OAAwB2B,EAAgB,MAErG,GADAI,EAAQK,EAAOL,MAAMkC,GACjBlC,EAAO,CACP,MAAO,CAAEmC,EAAQH,GAAUhC,EAC3B,MAAO,CACHQ,KAAMvD,EAASmF,cACfjC,OACAzB,OACA0B,WACA+B,SACAH,SAER,CAGA,MAAMK,EAAiB,IAAItC,OAAO,KAAD9B,OAAM4B,EAAwB,QAAA5B,OAAO4B,EAAwB,QAAA5B,OAAO4B,EAAwB,MAG7H,GADAG,EAAQK,EAAOL,MAAMqC,IAChBrC,EAED,OADAC,QAAQC,MAAM,2BAA4BP,GACnC,KAEX,MAAO,CAAEqC,EAAQvC,EAAc6C,GAAgBtC,EAE/C,MAAO,CACHQ,KAAMvD,EAASsF,OACfpC,OACAzB,OACA0B,WACA4B,SACAvC,eACA6C,aAAcE,SAASF,EAAc,IACxC,EAGE,SAASG,EAAiBC,EAAqBC,GAClD,IACI,MAAMC,EAAQF,EAAY7D,MAAM,MAChC,IAAIgE,EAAc,EACdC,EAAuB,GAE3B,IAAK,MAAMC,KAAQH,EAAO,CACtB,MAAMjD,EAAUD,EAAaqD,EAAKC,QAOlC,GALIrD,GACAmD,EAAUG,KAAKtD,GAGnBkD,IACIF,GAAoBE,EAAc,MAAQ,EAAG,CAE7CF,EADkBE,EAAcD,EAAMtE,OAAU,GAEpD,CACJ,CAEA,IAAI4E,EDtHL,SAAqBJ,EAAsBH,GAC9C,MAAMQ,EAAaL,EAAUxE,OAC7B,IAAIuE,EAAc,EAElB,MAAMK,EAAkB,GACxB,IAGI5B,EACAG,EACA2B,EALAC,EAA6B,KAC7BC,EAAiB,GACjBC,EAAqD,KAKzD,SAASC,EAAS7E,EAAmB8E,GAA8C,IAA5BC,IAAkBC,UAAArF,OAAA,QAAAsF,IAAAD,UAAA,KAAAA,UAAA,GACrEN,EAAc1E,SAAWA,EAEzB0E,EAAcQ,SAAW,CACrB1D,KAAMkD,EAAc5E,UAAU0B,KAC9B2D,YAAa1G,EAAiBiG,GAC9BU,KAAMV,EAAcU,KACpBN,QAASA,EACT/E,KAAM2E,EAAc5E,UAAUC,MAElCwE,EAAOD,KAAKI,GACRK,IACAL,EAAe,MAEnBE,EAAa,IACjB,CAEA,IAAK,MAAM5D,KAAWmD,EAAW,CAsB7B,GArBInD,EAAQa,OAASvD,EAAS2D,mBAC1B0C,EAAS3D,EAAQgB,gBAGjBhB,EAAQa,OAASvD,EAASoE,iBAC1BC,EAAgB3B,EAAQ2B,eAGxB3B,EAAQa,OAASvD,EAAS6E,mBAC1BL,EAAkB9B,EAAQ8B,iBAI1B4B,GAAgBE,GAAc/E,EAAoBmB,EAAQjB,MAAQF,EAAoB+E,EAAW7E,MAAQ,MAEzG2E,EAAahF,KAAOgF,EAAahF,KAAK2F,QAAO,CAAC3E,EAAK4E,IAAUA,GAASV,EAAYU,QAClFZ,EAAaU,MAAQ,gBACrBP,EAASH,EAAahF,KAAKgF,EAAahF,KAAKC,OAAS,IAAI,KAIzD+E,GAAgB1D,EAAQa,OAASvD,EAASsF,QAAUnD,EAAqBO,IAAYA,EAAQqC,SAAWsB,EAAQ,CACjHF,EAAiBc,IAAO,GAADjG,OAAI0B,EAAQQ,KAAI,KAAAlC,OAAI0B,EAAQjB,MAAQ,2BAA2ByF,SACtFxE,EAAQyE,UAAYpF,EAAoB,GAExC,MAAMqF,EAAyB,GAG3B/C,GACA+C,EAAYpB,KAAK,CACbzC,KAAMvD,EAASoE,eACflB,KAAMR,EAAQQ,KACdzB,KAAMiB,EAAQjB,KACd0B,SAAUT,EAAQS,SAClBkB,cAAeA,EACf8C,UAAWpF,EAAoB,KAKnCyC,GACA4C,EAAYpB,KAAK,CACbzC,KAAMvD,EAAS6E,iBACf3B,KAAMR,EAAQQ,KACdzB,KAAMiB,EAAQjB,KACd0B,SAAUT,EAAQS,SAClBqB,gBAAiBA,EACjB2C,UAAWpF,EAAoB,KAKvCqE,EAAe,CACXU,KAAMpE,EAAQqC,OACdsC,QAAS,CAAC3E,EAAQqC,QAClB3D,KAAM,IACCgG,EACH1E,GAEJgB,eAAgB2C,EAChB7E,UAAWkB,EACXhB,SAAUgB,EAElB,MAAO,GAAI0D,EAAc,CAEjB,WAAY1D,GAAWR,EAAWK,SAASG,EAAQqC,SAAYqB,EAAaU,OAASpE,EAAQqC,SAC7FqB,EAAaU,KAAOpE,EAAQqC,QAG5BrC,EAAQa,OAASvD,EAASsF,QAAUnD,EAAqBO,IAAYA,EAAQqC,SAAWsB,IAAWD,EAAaiB,QAAQ9E,SAASG,EAAQqC,SACzIqB,EAAaiB,QAAQrB,KAAKtD,EAAQqC,QAItC,MAAMuC,EAAUL,IAAO,GAADjG,OAAI0B,EAAQQ,KAAI,KAAAlC,OAAI0B,EAAQjB,MAAQ,2BAA2ByF,SACrFxE,EAAQyE,UAAYpF,EAAoBuF,EAAQC,UAAYpB,EAAgBoB,WAE5EnB,EAAahF,KAAK4E,KAAKtD,EAC3B,CAEI0D,GAAgB1D,EAAQa,OAASvD,EAASsF,QAAUnD,EAAqBO,KACzE4D,EAAa,CACT7E,KAAMiB,EAAQjB,KACduF,MAAOZ,EAAahF,KAAKC,OAAS,IAItCqB,EAAQa,OAASvD,EAASgF,OAAStC,EAAQqC,QAEvCqB,IACI1D,EAAQqC,SAAWqB,EAAaU,KAChCP,EAAS7D,GAAS,GACXA,EAAQqC,SAAWqB,EAAa1C,gBACvC6C,EAAS7D,GAAS,IAK9BkD,IACIF,GAAoBE,EAAc,MAAQ,GAE1CF,EADiB,GAAME,EAAcM,EAAc,GAG3D,CAGIE,GACAG,EAASH,EAAahF,KAAKgF,EAAahF,KAAKC,OAAS,IAAI,GAAO,GAGrE,MAAMmG,EAAuC,IAAIC,IAsBjD,OApBuBxB,EAAOc,QAAQ5F,IAKlC,IAHwBA,EAAMC,KAAKsG,MAAMhF,GACrCA,EAAQa,OAASvD,EAASsF,QAAUnD,EAAqBO,KAGzD,OAAO,EAIX,IAAIiF,EAAQ,EAOZ,OANIH,EAAgBI,IAAIzG,EAAM2F,QAC1Ba,EAAQH,EAAgBK,IAAI1G,EAAM2F,MAAS,GAE/CU,EAAgBM,IAAI3G,EAAM2F,KAAMa,GAChCxG,EAAM2F,KAAI,GAAA9F,OAAMG,EAAM2F,KAAI,OAAA9F,OAAM2G,IAEzB,CAAI,GAInB,CC7C8BI,CAAYlC,EAAWH,GAE7C,OAAOO,CACX,CAAE,MAAOhD,GAEL,OADAD,QAAQC,MAAM,8BAA+BA,GACtC,IACX,CACJ,C,aC3JA,MAAM+E,E,MAAgBC,GAAAA,eAA2B,CAC7CnB,KAAM,gBA+BVoB,UAAaC,IACT,MAAM,KAAC5E,EAAI,YAAEkC,EAAW,MAAEuB,GAASmB,EAAM/G,KAC5B,UAATmC,EA9BR,SAA+BkC,GAC3B,MAAM2C,EAAe5C,EAAiBC,GAAc4C,IAChDC,YAAY,CAAC/E,KAAM,WAAY8E,YAAU,IAIvCE,EAAqB,CACvBC,eAF8B,OAAZJ,QAAY,IAAZA,OAAY,EAAZA,EAAcvG,KAAIV,GAASA,EAAMyF,aAAa,GAGhE6B,YAAaL,EAAc,IAG/BE,YAAY,CAAC/E,KAAM,cAAegF,uBAClCP,EAAcU,QAAQ,YAAaN,EACvC,CAkBQO,CAAsBlD,GACN,YAATlC,GAjBf,SAAyByD,GACrBgB,EAAcY,QAAiB,aAAaC,MAAMT,GAC1CA,GAAgBpB,GAAS,GAAKA,EAAQoB,EAAa/G,OAC5C+G,EAAapB,GAEjB,OACR6B,MAAMlE,IACL2D,YAAY,CAAC/E,KAAM,OAAQoB,QAAM,IAClCmE,OAAO7F,IACND,QAAQC,MAAM,+BAAgCA,EAAM,GAE5D,CAOQ8F,CAAgB/B,EACpB,C,GCzCAgC,EAA2B,CAAC,EAGhC,SAASC,EAAoBC,GAE5B,IAAIC,EAAeH,EAAyBE,GAC5C,QAAqBvC,IAAjBwC,EACH,OAAOA,EAAaC,QAGrB,IAAIC,EAASL,EAAyBE,GAAY,CACjDI,GAAIJ,EACJK,QAAQ,EACRH,QAAS,CAAC,GAUX,OANAI,EAAoBN,GAAUO,KAAKJ,EAAOD,QAASC,EAAQA,EAAOD,QAASH,GAG3EI,EAAOE,QAAS,EAGTF,EAAOD,OACf,CAGAH,EAAoBS,EAAIF,EAGxBP,EAAoBU,EAAI,KAGvB,IAAIC,EAAsBX,EAAoBY,OAAElD,EAAW,CAAC,MAAM,IAAOsC,EAAoB,QAE7F,OADAW,EAAsBX,EAAoBY,EAAED,EAClB,E,MCpC3B,IAAIE,EAAW,GACfb,EAAoBY,EAAI,CAACE,EAAQC,EAAUC,EAAIC,KAC9C,IAAGF,EAAH,CAMA,IAAIG,EAAeC,IACnB,IAASC,EAAI,EAAGA,EAAIP,EAASzI,OAAQgJ,IAAK,CACrCL,EAAWF,EAASO,GAAG,GACvBJ,EAAKH,EAASO,GAAG,GACjBH,EAAWJ,EAASO,GAAG,GAE3B,IAJA,IAGIC,GAAY,EACPC,EAAI,EAAGA,EAAIP,EAAS3I,OAAQkJ,MACpB,EAAXL,GAAsBC,GAAgBD,IAAa7H,OAAOmI,KAAKvB,EAAoBY,GAAGY,OAAOC,GAASzB,EAAoBY,EAAEa,GAAKV,EAASO,MAC9IP,EAASW,OAAOJ,IAAK,IAErBD,GAAY,EACTJ,EAAWC,IAAcA,EAAeD,IAG7C,GAAGI,EAAW,CACbR,EAASa,OAAON,IAAK,GACrB,IAAIO,EAAIX,SACEtD,IAANiE,IAAiBb,EAASa,EAC/B,CACD,CACA,OAAOb,CArBP,CAJCG,EAAWA,GAAY,EACvB,IAAI,IAAIG,EAAIP,EAASzI,OAAQgJ,EAAI,GAAKP,EAASO,EAAI,GAAG,GAAKH,EAAUG,IAAKP,EAASO,GAAKP,EAASO,EAAI,GACrGP,EAASO,GAAK,CAACL,EAAUC,EAAIC,EAuBjB,C,KC3BdjB,EAAoB4B,EAAKxB,IACxB,IAAIyB,EAASzB,GAAUA,EAAO0B,WAC7B,IAAO1B,EAAiB,QACxB,IAAM,EAEP,OADAJ,EAAoB+B,EAAEF,EAAQ,CAAEG,EAAGH,IAC5BA,CAAM,ECLd7B,EAAoB+B,EAAI,CAAC5B,EAAS8B,KACjC,IAAI,IAAIR,KAAOQ,EACXjC,EAAoBkC,EAAED,EAAYR,KAASzB,EAAoBkC,EAAE/B,EAASsB,IAC5ErI,OAAO+I,eAAehC,EAASsB,EAAK,CAAEW,YAAY,EAAMxD,IAAKqD,EAAWR,IAE1E,ECNDzB,EAAoBqC,EAAI,CAAC,EAGzBrC,EAAoBsC,EAAKC,GACjBC,QAAQC,IAAIrJ,OAAOmI,KAAKvB,EAAoBqC,GAAGK,QAAO,CAACC,EAAUlB,KACvEzB,EAAoBqC,EAAEZ,GAAKc,EAASI,GAC7BA,IACL,KCNJ3C,EAAoB4C,EAAKL,GAEjB,aAAeA,EAAf,qBCFRvC,EAAoB6C,SAAYN,IAEf,ECHjBvC,EAAoB8C,EAAI,WACvB,GAA0B,kBAAfC,WAAyB,OAAOA,WAC3C,IACC,OAAOC,MAAQ,IAAIC,SAAS,cAAb,EAChB,CAAE,MAAOX,GACR,GAAsB,kBAAXY,OAAqB,OAAOA,MACxC,CACA,CAPuB,GCAxBlD,EAAoBkC,EAAI,CAACiB,EAAKC,IAAUhK,OAAOiK,UAAUC,eAAe9C,KAAK2C,EAAKC,GCAlFpD,EAAoBuD,IAAOnD,IAC1BA,EAAOoD,MAAQ,GACVpD,EAAOqD,WAAUrD,EAAOqD,SAAW,IACjCrD,GCHRJ,EAAoB0D,EAAI,I,MCIxB,IAAIC,EAAkB,CACrB,IAAK,GAkBN3D,EAAoBqC,EAAEjB,EAAI,CAACmB,EAASI,KAE/BgB,EAAgBpB,IAElBqB,cAAc5D,EAAoB0D,EAAI1D,EAAoB4C,EAAEL,GAE9D,EAGD,IAAIsB,EAAqBC,KAA2B,qBAAIA,KAA2B,sBAAK,GACpFC,EAA6BF,EAAmB9G,KAAKiH,KAAKH,GAC9DA,EAAmB9G,KAzBC5E,IACnB,IAAI4I,EAAW5I,EAAK,GAChB8L,EAAc9L,EAAK,GACnB+L,EAAU/L,EAAK,GACnB,IAAI,IAAI8H,KAAYgE,EAChBjE,EAAoBkC,EAAE+B,EAAahE,KACrCD,EAAoBS,EAAER,GAAYgE,EAAYhE,IAIhD,IADGiE,GAASA,EAAQlE,GACde,EAAS3I,QACduL,EAAgB5C,EAASoD,OAAS,EACnCJ,EAA2B5L,EAAK,C,WCrBjC,IAAIiM,EAAOpE,EAAoBU,EAC/BV,EAAoBU,EAAI,IAChBV,EAAoBsC,EAAE,KAAK1C,KAAKwE,E,KCDdpE,EAAoBU,G","sources":["models/LogLine.ts","HitsplatNames.ts","utils/utils.ts","utils/LogSplitter.ts","utils/FileParser.ts","components/FileParserWorker.ts","../webpack/bootstrap","../webpack/runtime/chunk loaded","../webpack/runtime/compat get default export","../webpack/runtime/define property getters","../webpack/runtime/ensure chunk","../webpack/runtime/get javascript chunk filename","../webpack/runtime/get mini-css chunk filename","../webpack/runtime/global","../webpack/runtime/hasOwnProperty shorthand","../webpack/runtime/node module decorator","../webpack/runtime/publicPath","../webpack/runtime/importScripts chunk loading","../webpack/runtime/startup chunk dependencies","../webpack/startup"],"sourcesContent":["import {BoostedLevels} from \"./BoostedLevels\";\n\nexport enum LogTypes {\n    LOG_VERSION = 'Log Version',\n    LOGGED_IN_PLAYER = 'Logged In Player',\n    BOOSTED_LEVELS = 'Boosted Levels',\n    PLAYER_EQUIPMENT = 'Player Equipment',\n    DEATH = 'Death',\n    TARGET_CHANGE = 'Target Change',\n    DAMAGE = 'Damage'\n}\n\nexport interface BaseLog {\n    date: string;\n    time: string;\n    timezone: string;\n    fightTime?: string;\n}\n\nexport interface LogVersionLog extends BaseLog {\n    type: LogTypes.LOG_VERSION;\n    logVersion: string;\n}\n\n\nexport interface LoggedInPlayerLog extends BaseLog {\n    type: LogTypes.LOGGED_IN_PLAYER;\n    loggedInPlayer: string;\n}\n\nexport interface BoostedLevelsLog extends BaseLog {\n    type: LogTypes.BOOSTED_LEVELS;\n    boostedLevels: BoostedLevels;\n}\n\nexport interface PlayerEquipmentLog extends BaseLog {\n    type: LogTypes.PLAYER_EQUIPMENT;\n    playerEquipment: string[];\n}\n\nexport interface DeathLog extends BaseLog {\n    type: LogTypes.DEATH;\n    target: string;\n}\n\nexport interface TargetChangeLog extends BaseLog {\n    type: LogTypes.TARGET_CHANGE;\n    source: string;\n    target: string;\n}\n\nexport interface DamageLog extends BaseLog {\n    type: LogTypes.DAMAGE;\n    target: string;\n    hitsplatName: string;\n    damageAmount: number;\n}\n\nexport type LogLine =\n    LogVersionLog\n    | LoggedInPlayerLog\n    | BoostedLevelsLog\n    | PlayerEquipmentLog\n    | DeathLog\n    | TargetChangeLog\n    | DamageLog;\n\nexport function filterByType<T extends LogLine['type']>(logs: LogLine[], type: T): Extract<LogLine, { type: T }>[] {\n    return logs.filter(log => log.type === type) as Extract<LogLine, { type: T }>[];\n}\n\n","export enum HitsplatNames {\n    POISON = 2,\n    DISEASE = 4,\n    VENOM = 5,\n    HEAL = 6,\n    BLOCK_ME = 12,\n    BLOCK_OTHER = 13,\n    DAMAGE_ME = 16,\n    DAMAGE_OTHER = 17,\n    DAMAGE_ME_CYAN = 18,\n    DAMAGE_OTHER_CYAN = 19,\n    DAMAGE_ME_ORANGE = 20,\n    DAMAGE_OTHER_ORANGE = 21,\n    DAMAGE_ME_YELLOW = 22,\n    DAMAGE_OTHER_YELLOW = 23,\n    DAMAGE_ME_WHITE = 24,\n    DAMAGE_OTHER_WHITE = 25,\n    DAMAGE_MAX_ME = 43,\n    DAMAGE_MAX_ME_CYAN = 44,\n    DAMAGE_MAX_ME_ORANGE = 45,\n    DAMAGE_MAX_ME_YELLOW = 46,\n    DAMAGE_MAX_ME_WHITE = 47,\n    SPLASH_ME = 69,\n}\n\nexport enum DamageMeHitsplats {\n    BLOCK_ME = HitsplatNames.BLOCK_ME,\n    DAMAGE_ME = HitsplatNames.DAMAGE_ME,\n    DAMAGE_ME_CYAN = HitsplatNames.DAMAGE_ME_CYAN,\n    DAMAGE_ME_ORANGE = HitsplatNames.DAMAGE_ME_ORANGE,\n    DAMAGE_ME_YELLOW = HitsplatNames.DAMAGE_ME_YELLOW,\n    DAMAGE_ME_WHITE = HitsplatNames.DAMAGE_ME_WHITE,\n    SPLASH_ME = HitsplatNames.SPLASH_ME,\n}\n\nexport enum DamageMaxMeHitsplats {\n    DAMAGE_MAX_ME = HitsplatNames.DAMAGE_MAX_ME,\n    DAMAGE_MAX_ME_CYAN = HitsplatNames.DAMAGE_MAX_ME_CYAN,\n    DAMAGE_MAX_ME_ORANGE = HitsplatNames.DAMAGE_MAX_ME_ORANGE,\n    DAMAGE_MAX_ME_YELLOW = HitsplatNames.DAMAGE_MAX_ME_YELLOW,\n    DAMAGE_MAX_ME_WHITE = HitsplatNames.DAMAGE_MAX_ME_WHITE,\n}\n\nexport enum DamageOtherHitsplats {\n    BLOCK_OTHER = HitsplatNames.BLOCK_OTHER,\n    DAMAGE_OTHER = HitsplatNames.DAMAGE_OTHER,\n    DAMAGE_OTHER_CYAN = HitsplatNames.DAMAGE_OTHER_CYAN,\n    DAMAGE_OTHER_ORANGE = HitsplatNames.DAMAGE_OTHER_ORANGE,\n    DAMAGE_OTHER_YELLOW = HitsplatNames.DAMAGE_OTHER_YELLOW,\n    DAMAGE_OTHER_WHITE = HitsplatNames.DAMAGE_OTHER_WHITE,\n}\n","import {Fight} from \"../models/Fight\";\nimport {LogLine, LogTypes} from \"../models/LogLine\";\n\nexport function getFightDuration(selectedLog: Fight) {\n    const fightDurationMilliseconds = calculateFightDuration(selectedLog!);\n    const duration = new Date(Date.UTC(0, 0, 0, 0, 0, 0, fightDurationMilliseconds));\n    const minutes = duration.getUTCMinutes();\n    const seconds = duration.getUTCSeconds();\n    const milliseconds = duration.getUTCMilliseconds();\n\n    const formattedDuration = `${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}.${milliseconds}`;\n    return formattedDuration;\n}\n\nexport const formatDurationToSeconds = (duration: string): string => {\n    // Split the duration string into minutes, seconds, and milliseconds\n    const [minutesStr, secondsStr] = duration.split(':');\n    const seconds = parseInt(minutesStr, 10) * 60 + parseFloat(secondsStr);\n\n    // Round up to the nearest second\n    const roundedSeconds = Math.round(seconds);\n\n    // Format the rounded seconds into mm:ss format\n    const formattedDuration = new Date(roundedSeconds * 1000).toISOString().substr(14, 5);\n\n    return formattedDuration;\n};\n\nexport const calculateFightDuration = (fight: Fight) => {\n    if (fight.data.length === 0) {\n        return 0;\n    }\n\n    const startTime = convertTimeToMillis(fight.firstLine.time);\n    const endTime = convertTimeToMillis(fight.lastLine.time);\n\n    return endTime - startTime;\n};\n\nexport function calculateAccuracy(fight: Fight) {\n    const hitsplatsCount = fight.data.filter(log => log.type === LogTypes.DAMAGE).length;\n    const successfulHitsplatsCount = fight.data.filter(log => log.type === LogTypes.DAMAGE && (log as LogLine & {\n        type: LogTypes.DAMAGE\n    }).damageAmount > 0).length;\n    const accuracyPercentage = hitsplatsCount > 0 ? (successfulHitsplatsCount / hitsplatsCount) * 100 : 0;\n    return accuracyPercentage;\n}\n\nexport const convertTimeToMillis = (time: string): number => {\n    const [hours, minutes, seconds] = time.split(':').map(Number);\n    const milliseconds = hours * 3600000 + minutes * 60000 + seconds * 1000;\n    return milliseconds;\n};\n\nexport function convertMillisToTime(duration: number): string {\n    const milliseconds = Math.floor(duration % 1000);\n    let seconds: any = Math.floor((duration / 1000) % 60);\n    let minutes: any = Math.floor((duration / (1000 * 60)) % 60);\n    let hours: any = Math.floor((duration / (1000 * 60 * 60)) % 24);\n\n    hours = (hours < 10) ? \"0\" + hours : hours;\n    minutes = (minutes < 10) ? \"0\" + minutes : minutes;\n    seconds = (seconds < 10) ? \"0\" + seconds : seconds;\n\n    const formattedMilliseconds = (milliseconds < 10) ? \"00\" + milliseconds : (milliseconds < 100) ? \"0\" + milliseconds : milliseconds;\n\n    return hours + \":\" + minutes + \":\" + seconds + \".\" + formattedMilliseconds;\n}","import {DamageLog, LogLine, LogTypes} from \"../models/LogLine\";\nimport {DamageMaxMeHitsplats, DamageMeHitsplats} from \"../HitsplatNames\";\nimport {Fight} from \"../models/Fight\";\nimport {BoostedLevels} from \"../models/BoostedLevels\";\nimport {convertMillisToTime, convertTimeToMillis, getFightDuration} from \"./utils\";\nimport moment from 'moment';\n\n\nconst BOSS_NAMES = [\n    \"Scurrius\",\n    \"Kree'arra\",\n    \"Commander Zilyana\",\n    \"General Graardor\",\n    \"K'ril Tsutsaroth\",\n    \"Nex\",\n    \"Kalphite Queen\",\n    \"Sarachnis\",\n    \"Scorpia\",\n    \"Abyssal Sire\",\n    \"Kraken\",\n    \"Dagannoth Rex\",\n    \"Dagannoth Supreme\",\n    \"Dagannoth Prime\"\n];\n\n/**\n * If it is the logged in player that dealt/attempted the damage\n */\nfunction playerAttemptsDamage(log: DamageLog) {\n    return Object.values(DamageMeHitsplats).includes(log.hitsplatName!) ||\n        Object.values(DamageMaxMeHitsplats).includes(log.hitsplatName!) ||\n        log.hitsplatName === 'BLOCK_ME';\n}\n\nexport function logSplitter(fightData: LogLine[], progressCallback?: (progress: number) => void): Fight[] {\n    const totalLines = fightData.length;\n    let parsedLines = 0;\n\n    const fights: Fight[] = [];\n    let currentFight: Fight | null = null;\n    let player: string = \"\"; //todo support multiple players\n    let lastDamage: { time: string, index: number } | null = null;\n    let boostedLevels: BoostedLevels | undefined;\n    let playerEquipment: string[] | undefined;\n    let fightStartTime: Date;\n\n    function endFight(lastLine: LogLine, success: boolean, nullFight: boolean = true) {\n        currentFight!.lastLine = lastLine;\n\n        currentFight!.metaData = {\n            date: currentFight!.firstLine.date,\n            fightLength: getFightDuration(currentFight!),\n            name: currentFight!.name,\n            success: success,\n            time: currentFight!.firstLine.time\n        }\n        fights.push(currentFight!);\n        if (nullFight) {\n            currentFight = null;\n        }\n        lastDamage = null;\n    }\n\n    for (const logLine of fightData) {\n        if (logLine.type === LogTypes.LOGGED_IN_PLAYER) {\n            player = logLine.loggedInPlayer;\n        }\n\n        if (logLine.type === LogTypes.BOOSTED_LEVELS) {\n            boostedLevels = logLine.boostedLevels;\n        }\n\n        if (logLine.type === LogTypes.PLAYER_EQUIPMENT) {\n            playerEquipment = logLine.playerEquipment;\n        }\n\n        // If there's a gap of over 60 seconds end the current fight\n        if (currentFight && lastDamage && convertTimeToMillis(logLine.time) - convertTimeToMillis(lastDamage.time) > 60000) {\n            // eslint-disable-next-line no-loop-func\n            currentFight.data = currentFight.data.filter((log, index) => index <= lastDamage!.index);\n            currentFight.name += \" - Incomplete\";\n            endFight(currentFight.data[currentFight.data.length - 1], false);\n        }\n\n        // If the current fight is null, start a new fight\n        if (!currentFight && logLine.type === LogTypes.DAMAGE && playerAttemptsDamage(logLine) && logLine.target !== player) {\n            fightStartTime = moment(`${logLine.date} ${logLine.time}`, 'MM-DD-YYYY HH:mm:ss.SSS').toDate();\n            logLine.fightTime = convertMillisToTime(0);\n\n            const initialData: LogLine[] = [];\n\n            // Include current boosted levels at the beginning of the fight\n            if (boostedLevels) {\n                initialData.push({\n                    type: LogTypes.BOOSTED_LEVELS,\n                    date: logLine.date,\n                    time: logLine.time,\n                    timezone: logLine.timezone,\n                    boostedLevels: boostedLevels,\n                    fightTime: convertMillisToTime(0)\n                });\n            }\n\n            // Include current player equipment at the beginning of the fight\n            if (playerEquipment) {\n                initialData.push({\n                    type: LogTypes.PLAYER_EQUIPMENT,\n                    date: logLine.date,\n                    time: logLine.time,\n                    timezone: logLine.timezone,\n                    playerEquipment: playerEquipment,\n                    fightTime: convertMillisToTime(0)\n                });\n            }\n\n            // @ts-ignore\n            currentFight = {\n                name: logLine.target,\n                enemies: [logLine.target],\n                data: [\n                    ...initialData,\n                    logLine\n                ],\n                loggedInPlayer: player,\n                firstLine: logLine,\n                lastLine: logLine\n            };\n        } else if (currentFight) {\n            // Rename the fight if we encounter a boss in the middle of it\n            if (\"target\" in logLine && BOSS_NAMES.includes(logLine.target!) && currentFight.name !== logLine.target) {\n                currentFight.name = logLine.target!;\n            }\n            // Add target to list of enemies\n            if (logLine.type === LogTypes.DAMAGE && playerAttemptsDamage(logLine) && logLine.target !== player && !currentFight.enemies.includes(logLine.target!)) {\n                currentFight.enemies.push(logLine.target!);\n            }\n\n            // Subtract the start time from the log's timestamp to get the relative time within the fight\n            const logDate = moment(`${logLine.date} ${logLine.time}`, 'MM-DD-YYYY HH:mm:ss.SSS').toDate();\n            logLine.fightTime = convertMillisToTime(logDate.getTime() - fightStartTime!.getTime());\n\n            currentFight.data.push(logLine);\n        }\n\n        if (currentFight && logLine.type === LogTypes.DAMAGE && playerAttemptsDamage(logLine)) {\n            lastDamage = {\n                time: logLine.time,\n                index: currentFight.data.length - 1\n            };\n        }\n\n        if (logLine.type === LogTypes.DEATH && logLine.target) {\n            // If the player or the fight name dies, end the current fight\n            if (currentFight) {\n                if (logLine.target === currentFight.name) {\n                    endFight(logLine, true);\n                } else if (logLine.target === currentFight.loggedInPlayer) {\n                    endFight(logLine, false);\n                }\n            }\n        }\n\n        parsedLines++;\n        if (progressCallback && parsedLines % 200 === 0) {\n            const progress = 50 + (parsedLines / totalLines) * 50;\n            progressCallback(progress);\n        }\n    }\n\n    // If we reach the end of the logs, end the current fight\n    if (currentFight) {\n        endFight(currentFight.data[currentFight.data.length - 1], false, false);\n    }\n\n    const fightNameCounts: Map<string, number> = new Map(); // Map to store counts of each fight name\n\n    const filteredFights = fights.filter((fight) => {\n        // If the fight has no damage logs from the player, discard it\n        const hasPlayerDamage = fight.data.some((logLine) =>\n            logLine.type === LogTypes.DAMAGE && playerAttemptsDamage(logLine)\n        );\n        if (!hasPlayerDamage) {\n            return false;\n        }\n\n        // Make fight names unique\n        let count = 1;\n        if (fightNameCounts.has(fight.name)) {\n            count = fightNameCounts.get(fight.name)! + 1;\n        }\n        fightNameCounts.set(fight.name, count);\n        fight.name = `${fight.name} - ${count}`;\n\n        return true;\n    });\n\n    return filteredFights;\n}\n","import {logSplitter} from \"./LogSplitter\";\nimport {Fight} from \"../models/Fight\";\nimport {LogLine, LogTypes} from \"../models/LogLine\";\n\nexport const parseLogLine = (logLine: string): LogLine | null => {\n    const DATE_PATTERN = '\\\\d{2}-\\\\d{2}-\\\\d{4}';\n    const TIME_PATTERN = '\\\\d{2}:\\\\d{2}:\\\\d{2}\\\\.\\\\d{3}';\n    const TIMEZONE_PATTERN = '\\\\w+';\n    const ANYTHING_PATTERN = '.*';\n    const ANYTHING_BUT_TAB_PATTERN = '[^\\\\t]*';\n\n    const pattern = new RegExp(`^(${DATE_PATTERN}) (${TIME_PATTERN}) (${TIMEZONE_PATTERN})\\t(${ANYTHING_PATTERN})`);\n\n    let match = logLine.match(pattern);\n\n    if (!match) {\n        console.error('Invalid log line format:', logLine);\n        return null;\n    }\n    const [, date, time, timezone, action] = match;\n\n\n    const logVersionPattern = new RegExp(`Log Version (${ANYTHING_PATTERN})`)\n    match = action.match(logVersionPattern);\n    if (match) {\n        const [, logVersion] = match;\n        console.log(`Log Version ${logVersion}`);\n        return {\n            type: LogTypes.LOG_VERSION,\n            date,\n            time,\n            timezone,\n            logVersion\n        };\n    }\n    const loggedInPlayerPattern = new RegExp(`Logged in player is (${ANYTHING_PATTERN})`)\n    match = action.match(loggedInPlayerPattern);\n    if (match) {\n        const [, loggedInPlayer] = match;\n        return {\n            type: LogTypes.LOGGED_IN_PLAYER,\n            date,\n            time,\n            timezone,\n            loggedInPlayer\n        };\n    }\n\n    const boostedLevelsPattern = new RegExp(`Boosted levels are \\\\[(\\\\d+), (\\\\d+), (\\\\d+), (\\\\d+), (\\\\d+), (\\\\d+), (\\\\d+)\\\\]`);\n    match = action.match(boostedLevelsPattern);\n    if (match) {\n        const [, attack, strength, defence, ranged, magic, hitpoints, prayer] = match.map(Number);\n\n        return {\n            type: LogTypes.BOOSTED_LEVELS,\n            date,\n            time,\n            timezone,\n            boostedLevels: {\n                attack,\n                strength,\n                defence,\n                ranged,\n                magic,\n                hitpoints,\n                prayer\n            }\n        };\n    }\n\n    const playerEquipmentPattern = new RegExp(`Player equipment is (${ANYTHING_PATTERN})`)\n    match = action.match(playerEquipmentPattern);\n    if (match) {\n        const [, equpimentString] = match;\n        const playerEquipment: string[] = JSON.parse(equpimentString).map((item: number) => item.toString());\n        return {\n            type: LogTypes.PLAYER_EQUIPMENT,\n            date,\n            time,\n            timezone,\n            playerEquipment\n        };\n    }\n\n    const diesPattern = new RegExp(`^(${ANYTHING_PATTERN}) dies`)\n    match = action.match(diesPattern);\n    if (match) {\n        const [, target] = match;\n        return {\n            type: LogTypes.DEATH,\n            date,\n            time,\n            timezone,\n            target,\n        };\n    }\n\n    const changedTargetPattern = new RegExp(`^(${ANYTHING_PATTERN}) changes target to (${ANYTHING_PATTERN})`)\n    match = action.match(changedTargetPattern);\n    if (match) {\n        const [, source, target] = match;\n        return {\n            type: LogTypes.TARGET_CHANGE,\n            date,\n            time,\n            timezone,\n            source,\n            target\n        };\n    }\n\n\n    const defaultPattern = new RegExp(`^(${ANYTHING_BUT_TAB_PATTERN})\\t(${ANYTHING_BUT_TAB_PATTERN})\\t(${ANYTHING_BUT_TAB_PATTERN})`);\n\n    match = action.match(defaultPattern);\n    if (!match) {\n        console.error('Invalid log line format:', logLine);\n        return null;\n    }\n    const [, target, hitsplatName, damageAmount] = match;\n\n    return {\n        type: LogTypes.DAMAGE,\n        date,\n        time,\n        timezone,\n        target,\n        hitsplatName,\n        damageAmount: parseInt(damageAmount, 10),\n    };\n};\n\nexport function parseFileContent(fileContent: string, progressCallback: (progress: number) => void): Fight[] | null {\n    try {\n        const lines = fileContent.split('\\n');\n        let parsedLines = 0;\n        let fightData: LogLine[] = [];\n\n        for (const line of lines) {\n            const logLine = parseLogLine(line.trim());\n\n            if (logLine) {\n                fightData.push(logLine);\n            }\n\n            parsedLines++;\n            if (progressCallback && parsedLines % 200 === 0) {\n                const progress = (parsedLines / lines.length) * 50;\n                progressCallback(progress);\n            }\n        }\n\n        let fights: Fight[] = logSplitter(fightData, progressCallback);\n\n        return fights;\n    } catch (error) {\n        console.error('Error parsing file content:', error);\n        return null;\n    }\n}\n\n","import {Fight} from \"../models/Fight\";\nimport {parseFileContent} from \"../utils/FileParser\";\nimport localforage from 'localforage';\n\nconst fightsStorage = localforage.createInstance({\n    name: 'myFightData'\n});\n\nfunction parseFileWithProgress(fileContent: string) {\n    const parseResults = parseFileContent(fileContent, (progress) => {\n        postMessage({type: 'progress', progress});\n    });\n\n    const fightMetadata = parseResults?.map(fight => fight.metaData) || [];\n    const parseResultMessage = {\n        fightMetadata,\n        firstResult: parseResults![0],\n    }\n\n    postMessage({type: 'parseResult', parseResultMessage});\n    fightsStorage.setItem('fightData', parseResults);\n}\n\nfunction getSpecificItem(index: number) {\n    fightsStorage.getItem<Fight[]>('fightData').then((parseResults: Fight[] | null) => {\n        if (parseResults && index >= 0 && index < parseResults.length) {\n            return parseResults[index];\n        }\n        return null;\n    }).then((item) => {\n        postMessage({type: 'item', item});\n    }).catch((error) => {\n        console.error(\"Error getting specific item:\", error);\n    });\n}\n\nonmessage = (event) => {\n    const {type, fileContent, index} = event.data;\n    if (type === 'parse') {\n        parseFileWithProgress(fileContent);\n    } else if (type === 'getItem') {\n        getSpecificItem(index);\n    }\n};\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\tid: moduleId,\n\t\tloaded: false,\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Flag the module as loaded\n\tmodule.loaded = true;\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n// expose the modules object (__webpack_modules__)\n__webpack_require__.m = __webpack_modules__;\n\n// the startup function\n__webpack_require__.x = () => {\n\t// Load entry module and return exports\n\t// This entry module depends on other loaded chunks and execution need to be delayed\n\tvar __webpack_exports__ = __webpack_require__.O(undefined, [200], () => (__webpack_require__(3839)))\n\t__webpack_exports__ = __webpack_require__.O(__webpack_exports__);\n\treturn __webpack_exports__;\n};\n\n","var deferred = [];\n__webpack_require__.O = (result, chunkIds, fn, priority) => {\n\tif(chunkIds) {\n\t\tpriority = priority || 0;\n\t\tfor(var i = deferred.length; i > 0 && deferred[i - 1][2] > priority; i--) deferred[i] = deferred[i - 1];\n\t\tdeferred[i] = [chunkIds, fn, priority];\n\t\treturn;\n\t}\n\tvar notFulfilled = Infinity;\n\tfor (var i = 0; i < deferred.length; i++) {\n\t\tvar chunkIds = deferred[i][0];\n\t\tvar fn = deferred[i][1];\n\t\tvar priority = deferred[i][2];\n\t\tvar fulfilled = true;\n\t\tfor (var j = 0; j < chunkIds.length; j++) {\n\t\t\tif ((priority & 1 === 0 || notFulfilled >= priority) && Object.keys(__webpack_require__.O).every((key) => (__webpack_require__.O[key](chunkIds[j])))) {\n\t\t\t\tchunkIds.splice(j--, 1);\n\t\t\t} else {\n\t\t\t\tfulfilled = false;\n\t\t\t\tif(priority < notFulfilled) notFulfilled = priority;\n\t\t\t}\n\t\t}\n\t\tif(fulfilled) {\n\t\t\tdeferred.splice(i--, 1)\n\t\t\tvar r = fn();\n\t\t\tif (r !== undefined) result = r;\n\t\t}\n\t}\n\treturn result;\n};","// getDefaultExport function for compatibility with non-harmony modules\n__webpack_require__.n = (module) => {\n\tvar getter = module && module.__esModule ?\n\t\t() => (module['default']) :\n\t\t() => (module);\n\t__webpack_require__.d(getter, { a: getter });\n\treturn getter;\n};","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.f = {};\n// This file contains only the entry chunk.\n// The chunk loading function for additional chunks\n__webpack_require__.e = (chunkId) => {\n\treturn Promise.all(Object.keys(__webpack_require__.f).reduce((promises, key) => {\n\t\t__webpack_require__.f[key](chunkId, promises);\n\t\treturn promises;\n\t}, []));\n};","// This function allow to reference async chunks and sibling chunks for the entrypoint\n__webpack_require__.u = (chunkId) => {\n\t// return url for filenames based on template\n\treturn \"static/js/\" + chunkId + \".\" + \"d42d81b7\" + \".chunk.js\";\n};","// This function allow to reference async chunks and sibling chunks for the entrypoint\n__webpack_require__.miniCssF = (chunkId) => {\n\t// return url for filenames based on template\n\treturn undefined;\n};","__webpack_require__.g = (function() {\n\tif (typeof globalThis === 'object') return globalThis;\n\ttry {\n\t\treturn this || new Function('return this')();\n\t} catch (e) {\n\t\tif (typeof window === 'object') return window;\n\t}\n})();","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","__webpack_require__.nmd = (module) => {\n\tmodule.paths = [];\n\tif (!module.children) module.children = [];\n\treturn module;\n};","__webpack_require__.p = \"/\";","// no baseURI\n\n// object to store loaded chunks\n// \"1\" means \"already loaded\"\nvar installedChunks = {\n\t220: 1\n};\n\n// importScripts chunk loading\nvar installChunk = (data) => {\n\tvar chunkIds = data[0];\n\tvar moreModules = data[1];\n\tvar runtime = data[2];\n\tfor(var moduleId in moreModules) {\n\t\tif(__webpack_require__.o(moreModules, moduleId)) {\n\t\t\t__webpack_require__.m[moduleId] = moreModules[moduleId];\n\t\t}\n\t}\n\tif(runtime) runtime(__webpack_require__);\n\twhile(chunkIds.length)\n\t\tinstalledChunks[chunkIds.pop()] = 1;\n\tparentChunkLoadingFunction(data);\n};\n__webpack_require__.f.i = (chunkId, promises) => {\n\t// \"1\" is the signal for \"already loaded\"\n\tif(!installedChunks[chunkId]) {\n\t\tif(true) { // all chunks have JS\n\t\t\timportScripts(__webpack_require__.p + __webpack_require__.u(chunkId));\n\t\t}\n\t}\n};\n\nvar chunkLoadingGlobal = self[\"webpackChunkrunelogs\"] = self[\"webpackChunkrunelogs\"] || [];\nvar parentChunkLoadingFunction = chunkLoadingGlobal.push.bind(chunkLoadingGlobal);\nchunkLoadingGlobal.push = installChunk;\n\n// no HMR\n\n// no HMR manifest","var next = __webpack_require__.x;\n__webpack_require__.x = () => {\n\treturn __webpack_require__.e(200).then(next);\n};","// run startup\nvar __webpack_exports__ = __webpack_require__.x();\n"],"names":["LogTypes","DamageMeHitsplats","DamageMaxMeHitsplats","getFightDuration","selectedLog","fightDurationMilliseconds","calculateFightDuration","duration","Date","UTC","minutes","getUTCMinutes","seconds","getUTCSeconds","milliseconds","getUTCMilliseconds","concat","String","padStart","fight","data","length","startTime","convertTimeToMillis","firstLine","time","lastLine","hours","split","map","Number","convertMillisToTime","Math","floor","BOSS_NAMES","playerAttemptsDamage","log","Object","values","includes","hitsplatName","parseLogLine","logLine","ANYTHING_PATTERN","ANYTHING_BUT_TAB_PATTERN","pattern","RegExp","match","console","error","date","timezone","action","logVersionPattern","logVersion","type","LOG_VERSION","loggedInPlayerPattern","loggedInPlayer","LOGGED_IN_PLAYER","boostedLevelsPattern","attack","strength","defence","ranged","magic","hitpoints","prayer","BOOSTED_LEVELS","boostedLevels","playerEquipmentPattern","equpimentString","playerEquipment","JSON","parse","item","toString","PLAYER_EQUIPMENT","diesPattern","target","DEATH","changedTargetPattern","source","TARGET_CHANGE","defaultPattern","damageAmount","DAMAGE","parseInt","parseFileContent","fileContent","progressCallback","lines","parsedLines","fightData","line","trim","push","fights","totalLines","fightStartTime","currentFight","player","lastDamage","endFight","success","nullFight","arguments","undefined","metaData","fightLength","name","filter","index","moment","toDate","fightTime","initialData","enemies","logDate","getTime","fightNameCounts","Map","some","count","has","get","set","logSplitter","fightsStorage","localforage","onmessage","event","parseResults","progress","postMessage","parseResultMessage","fightMetadata","firstResult","setItem","parseFileWithProgress","getItem","then","catch","getSpecificItem","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","exports","module","id","loaded","__webpack_modules__","call","m","x","__webpack_exports__","O","deferred","result","chunkIds","fn","priority","notFulfilled","Infinity","i","fulfilled","j","keys","every","key","splice","r","n","getter","__esModule","d","a","definition","o","defineProperty","enumerable","f","e","chunkId","Promise","all","reduce","promises","u","miniCssF","g","globalThis","this","Function","window","obj","prop","prototype","hasOwnProperty","nmd","paths","children","p","installedChunks","importScripts","chunkLoadingGlobal","self","parentChunkLoadingFunction","bind","moreModules","runtime","pop","next"],"sourceRoot":""}