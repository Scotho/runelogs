{"version":3,"file":"static/js/388.40698211.chunk.js","mappings":"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","sources":["models/LogLine.ts","HitsplatNames.ts","utils/constants.ts","utils/LogSplitter.ts","utils/FileParser.ts","components/FileParserWorker.ts","../webpack/bootstrap","../webpack/runtime/chunk loaded","../webpack/runtime/compat get default export","../webpack/runtime/define property getters","../webpack/runtime/ensure chunk","../webpack/runtime/get javascript chunk filename","../webpack/runtime/get mini-css chunk filename","../webpack/runtime/global","../webpack/runtime/hasOwnProperty shorthand","../webpack/runtime/node module decorator","../webpack/runtime/publicPath","../webpack/runtime/importScripts chunk loading","../webpack/runtime/startup chunk dependencies","../webpack/startup"],"sourcesContent":["import {BoostedLevels} from \"./BoostedLevels\";\n\nexport enum LogTypes {\n    LOG_VERSION = 'Log Version',\n    LOGGED_IN_PLAYER = 'Logged In Player',\n    BOOSTED_LEVELS = 'Boosted Levels',\n    PLAYER_EQUIPMENT = 'Player Equipment',\n    DEATH = 'Death',\n    TARGET_CHANGE = 'Target Change',\n    DAMAGE = 'Damage'\n}\n\nexport interface BaseLog {\n    date: string;\n    time: string;\n    timezone: string;\n    fightTimeMs?: number;\n}\n\nexport interface LogVersionLog extends BaseLog {\n    type: LogTypes.LOG_VERSION;\n    logVersion: string;\n}\n\n\nexport interface LoggedInPlayerLog extends BaseLog {\n    type: LogTypes.LOGGED_IN_PLAYER;\n    loggedInPlayer: string;\n}\n\nexport interface BoostedLevelsLog extends BaseLog {\n    type: LogTypes.BOOSTED_LEVELS;\n    boostedLevels: BoostedLevels;\n}\n\nexport interface PlayerEquipmentLog extends BaseLog {\n    type: LogTypes.PLAYER_EQUIPMENT;\n    playerEquipment: string[];\n}\n\nexport interface DeathLog extends BaseLog {\n    type: LogTypes.DEATH;\n    target: string;\n}\n\nexport interface TargetChangeLog extends BaseLog {\n    type: LogTypes.TARGET_CHANGE;\n    source: string;\n    target: string;\n}\n\nexport interface DamageLog extends BaseLog {\n    type: LogTypes.DAMAGE;\n    target: string;\n    hitsplatName: string;\n    damageAmount: number;\n}\n\nexport type LogLine =\n    LogVersionLog\n    | LoggedInPlayerLog\n    | BoostedLevelsLog\n    | PlayerEquipmentLog\n    | DeathLog\n    | TargetChangeLog\n    | DamageLog;\n\nexport function filterByType<T extends LogLine['type']>(logs: LogLine[], type: T): Extract<LogLine, { type: T }>[] {\n    return logs.filter(log => log.type === type) as Extract<LogLine, { type: T }>[];\n}\n\n","export enum HitsplatNames {\n    POISON = 2,\n    DISEASE = 4,\n    VENOM = 5,\n    HEAL = 6,\n    BLOCK_ME = 12,\n    BLOCK_OTHER = 13,\n    DAMAGE_ME = 16,\n    DAMAGE_OTHER = 17,\n    DAMAGE_ME_CYAN = 18,\n    DAMAGE_OTHER_CYAN = 19,\n    DAMAGE_ME_ORANGE = 20,\n    DAMAGE_OTHER_ORANGE = 21,\n    DAMAGE_ME_YELLOW = 22,\n    DAMAGE_OTHER_YELLOW = 23,\n    DAMAGE_ME_WHITE = 24,\n    DAMAGE_OTHER_WHITE = 25,\n    DAMAGE_MAX_ME = 43,\n    DAMAGE_MAX_ME_CYAN = 44,\n    DAMAGE_MAX_ME_ORANGE = 45,\n    DAMAGE_MAX_ME_YELLOW = 46,\n    DAMAGE_MAX_ME_WHITE = 47,\n    SPLASH_ME = 69,\n}\n\nexport enum DamageMeHitsplats {\n    BLOCK_ME = HitsplatNames.BLOCK_ME,\n    DAMAGE_ME = HitsplatNames.DAMAGE_ME,\n    DAMAGE_ME_CYAN = HitsplatNames.DAMAGE_ME_CYAN,\n    DAMAGE_ME_ORANGE = HitsplatNames.DAMAGE_ME_ORANGE,\n    DAMAGE_ME_YELLOW = HitsplatNames.DAMAGE_ME_YELLOW,\n    DAMAGE_ME_WHITE = HitsplatNames.DAMAGE_ME_WHITE,\n    SPLASH_ME = HitsplatNames.SPLASH_ME,\n}\n\nexport enum DamageMaxMeHitsplats {\n    DAMAGE_MAX_ME = HitsplatNames.DAMAGE_MAX_ME,\n    DAMAGE_MAX_ME_CYAN = HitsplatNames.DAMAGE_MAX_ME_CYAN,\n    DAMAGE_MAX_ME_ORANGE = HitsplatNames.DAMAGE_MAX_ME_ORANGE,\n    DAMAGE_MAX_ME_YELLOW = HitsplatNames.DAMAGE_MAX_ME_YELLOW,\n    DAMAGE_MAX_ME_WHITE = HitsplatNames.DAMAGE_MAX_ME_WHITE,\n}\n\nexport enum DamageOtherHitsplats {\n    BLOCK_OTHER = HitsplatNames.BLOCK_OTHER,\n    DAMAGE_OTHER = HitsplatNames.DAMAGE_OTHER,\n    DAMAGE_OTHER_CYAN = HitsplatNames.DAMAGE_OTHER_CYAN,\n    DAMAGE_OTHER_ORANGE = HitsplatNames.DAMAGE_OTHER_ORANGE,\n    DAMAGE_OTHER_YELLOW = HitsplatNames.DAMAGE_OTHER_YELLOW,\n    DAMAGE_OTHER_WHITE = HitsplatNames.DAMAGE_OTHER_WHITE,\n}\n","export const BOSS_NAMES = [\n    \"Scurrius\",\n    \"Kree'arra\",\n    \"Commander Zilyana\",\n    \"General Graardor\",\n    \"K'ril Tsutsaroth\",\n    \"Nex\",\n    \"Kalphite Queen\",\n    \"Sarachnis\",\n    \"Scorpia\",\n    \"Abyssal Sire\",\n    \"Kraken\",\n    \"Dagannoth Rex\",\n    \"Dagannoth Supreme\",\n    \"Dagannoth Prime\",\n    \"The Leviathan\",\n    \"The Whisperer\",\n    \"Vardorvis\",\n    \"Duke Sucellus\",\n    \"Tekton\",\n    \"Ice demon\",\n    \"Vanguard\",\n    \"Vespula\",\n    \"Vasa Nistirio\",\n    \"Muttadile\",\n    \"Great Olm\",\n    \"The Maiden of Sugadinti\",\n    \"Pestilent Bloat\",\n    \"Nylocas Vasilias\",\n    \"Sotetseg\",\n    \"Xarpus\",\n    \"Verzik Vitur\",\n    \"Ba-Ba\",\n    \"Akkha\",\n    \"Akkha's Shadow\",\n    \"Kephri\",\n    \"Zebak\",\n    \"Obelisk\",\n    \"Tumeken's Warden\",\n    \"Ahrim the Blighted\",\n    \"Dharok the Wretched\",\n    \"Guthan the Infested\",\n    \"Karil the Tainted\",\n    \"Torag the Corrupted\",\n    \"Verac the Defiled\",\n    \"Corporeal Beast\",\n    \"King Black Dragon\",\n    \"Vorkath\",\n    \"Zulrah\",\n    \"Fragment of Seren\",\n    \"Alchemical Hydra\",\n    \"Bryophyta\",\n    \"Callisto\",\n    \"Cerberus\",\n    \"Chaos Elemental\",\n    \"Chaos Fanatic\",\n    \"Crazy Archaeologist\",\n    \"Crystalline Hunllef\",\n    \"Corrupted Hunllef\",\n    \"Deranged Archaeologist\",\n    \"Giant Mole\",\n    \"Hespori\",\n    \"The Mimic\",\n    \"The Nightmare\",\n    \"Obor\",\n    \"Phantom Muspah\",\n    \"Skotizo\",\n    \"Thermonuclear Smoke Devil\",\n    \"TzKal-Zuk\",\n    \"TzTok-Jad\",\n    \"Venenatis\",\n    \"Vet'ion\",\n];","import {DamageLog, LogLine, LogTypes, TargetChangeLog} from \"../models/LogLine\";\nimport {DamageMaxMeHitsplats, DamageMeHitsplats} from \"../HitsplatNames\";\nimport {Fight} from \"../models/Fight\";\nimport {BoostedLevels} from \"../models/BoostedLevels\";\nimport moment from 'moment';\nimport {BOSS_NAMES} from \"./constants\";\n\n\n/**\n * If it is the logged in player that dealt/attempted the damage\n */\nfunction playerAttemptsDamage(log: DamageLog) {\n    return Object.values(DamageMeHitsplats).includes(log.hitsplatName!) ||\n        Object.values(DamageMaxMeHitsplats).includes(log.hitsplatName!) ||\n        log.hitsplatName === 'BLOCK_ME';\n}\n\n/**\n * If a boss targets the logged in player\n */\nfunction bossTargetsMe(player: string, log: TargetChangeLog) {\n    return log.target === player && BOSS_NAMES.includes(log.source);\n}\n\nexport function logSplitter(fightData: LogLine[], progressCallback?: (progress: number) => void): Fight[] {\n    const totalLines = fightData.length;\n    let parsedLines = 0;\n\n    const fights: Fight[] = [];\n    let currentFight: Fight | null = null;\n    let player: string = \"\"; //todo support multiple players\n    let lastDamage: { time: number, index: number } | null = null;\n    let boostedLevels: BoostedLevels | undefined;\n    let playerEquipment: string[] | undefined;\n    let fightStartTime: Date;\n\n    function endFight(lastLine: LogLine, success: boolean, nullFight: boolean = true) {\n        currentFight!.lastLine = lastLine;\n\n        currentFight!.metaData = {\n            date: currentFight!.firstLine.date,\n            fightLengthMs: currentFight!.lastLine.fightTimeMs! - currentFight!.firstLine.fightTimeMs!,\n            name: currentFight!.name,\n            success: success,\n            time: currentFight!.firstLine.time\n        }\n        fights.push(currentFight!);\n        if (nullFight) {\n            currentFight = null;\n        }\n        lastDamage = null;\n    }\n\n    for (const logLine of fightData) {\n        if (logLine.type === LogTypes.LOGGED_IN_PLAYER) {\n            player = logLine.loggedInPlayer;\n        }\n\n        if (logLine.type === LogTypes.BOOSTED_LEVELS) {\n            boostedLevels = logLine.boostedLevels;\n        }\n\n        if (logLine.type === LogTypes.PLAYER_EQUIPMENT) {\n            playerEquipment = logLine.playerEquipment;\n        }\n\n        // If there's a gap of over 60 seconds end the current fight\n        if (currentFight && lastDamage && moment(`${logLine.date} ${logLine.time}`, 'MM-DD-YYYY HH:mm:ss.SSS').toDate().getTime() - lastDamage.time > 60000) {\n            // eslint-disable-next-line no-loop-func\n            currentFight.data = currentFight.data.filter((log, index) => index <= lastDamage!.index);\n            currentFight.name += \" - Incomplete\";\n            endFight(currentFight.data[currentFight.data.length - 1], false);\n        }\n\n        // If the current fight is null, start a new fight\n        if (!currentFight &&\n            ((logLine.type === LogTypes.DAMAGE && playerAttemptsDamage(logLine) && logLine.target !== player) ||\n            (logLine.type === LogTypes.TARGET_CHANGE && bossTargetsMe(player, logLine)))) {\n            fightStartTime = moment(`${logLine.date} ${logLine.time}`, 'MM-DD-YYYY HH:mm:ss.SSS').toDate();\n            logLine.fightTimeMs = 0;\n\n            const initialData: LogLine[] = [];\n\n            // Include current boosted levels at the beginning of the fight\n            if (boostedLevels) {\n                initialData.push({\n                    type: LogTypes.BOOSTED_LEVELS,\n                    date: logLine.date,\n                    time: logLine.time,\n                    timezone: logLine.timezone,\n                    boostedLevels: boostedLevels,\n                    fightTimeMs: 0\n                });\n            }\n\n            // Include current player equipment at the beginning of the fight\n            if (playerEquipment) {\n                initialData.push({\n                    type: LogTypes.PLAYER_EQUIPMENT,\n                    date: logLine.date,\n                    time: logLine.time,\n                    timezone: logLine.timezone,\n                    playerEquipment: playerEquipment,\n                    fightTimeMs: 0\n                });\n            }\n\n            // @ts-ignore\n            currentFight = {\n                name: logLine.target,\n                enemies: [logLine.target],\n                data: [\n                    ...initialData,\n                    logLine\n                ],\n                loggedInPlayer: player,\n                firstLine: logLine,\n                lastLine: logLine\n            };\n        } else if (currentFight) {\n            // Rename the fight if we encounter a boss in the middle of it\n            if (\"target\" in logLine && BOSS_NAMES.includes(logLine.target!) && currentFight.name !== logLine.target) {\n                currentFight.name = logLine.target!;\n            }\n            // Add target to list of enemies\n            if (logLine.type === LogTypes.DAMAGE && playerAttemptsDamage(logLine) && logLine.target !== player && !currentFight.enemies.includes(logLine.target!)) {\n                currentFight.enemies.push(logLine.target!);\n            }\n\n            // Subtract the start time from the log's timestamp to get the relative time within the fight\n            const logDate = moment(`${logLine.date} ${logLine.time}`, 'MM-DD-YYYY HH:mm:ss.SSS').toDate();\n            logLine.fightTimeMs = logDate.getTime() - fightStartTime!.getTime();\n            currentFight.data.push(logLine);\n        }\n\n        if (currentFight && logLine.type === LogTypes.DAMAGE && playerAttemptsDamage(logLine)) {\n            lastDamage = {\n                time: moment(`${logLine.date} ${logLine.time}`, 'MM-DD-YYYY HH:mm:ss.SSS').toDate().getTime(),\n                index: currentFight.data.length - 1\n            };\n        }\n\n        if (logLine.type === LogTypes.DEATH && logLine.target) {\n            // If the player or the fight name dies, end the current fight\n            if (currentFight) {\n                if (logLine.target === currentFight.name) {\n                    endFight(logLine, true);\n                } else if (logLine.target === currentFight.loggedInPlayer) {\n                    endFight(logLine, false);\n                }\n            }\n        }\n\n        parsedLines++;\n        if (progressCallback && parsedLines % 200 === 0) {\n            const progress = 50 + (parsedLines / totalLines) * 50;\n            progressCallback(progress);\n        }\n    }\n\n    // If we reach the end of the logs, end the current fight\n    if (currentFight) {\n        endFight(currentFight.data[currentFight.data.length - 1], false, false);\n    }\n\n    const fightNameCounts: Map<string, number> = new Map(); // Map to store counts of each fight name\n\n    const filteredFights = fights.filter((fight) => {\n        // If the fight has no damage logs from the player, discard it\n        const hasPlayerDamage = fight.data.some((logLine) =>\n            logLine.type === LogTypes.DAMAGE && playerAttemptsDamage(logLine)\n        );\n        if (!hasPlayerDamage) {\n            return false;\n        }\n\n        // Make fight names unique\n        let count = 1;\n        if (fightNameCounts.has(fight.name)) {\n            count = fightNameCounts.get(fight.name)! + 1;\n        }\n        fightNameCounts.set(fight.name, count);\n        fight.name = `${fight.name} - ${count}`;\n\n        return true;\n    });\n\n    return filteredFights;\n}\n","import {logSplitter} from \"./LogSplitter\";\nimport {Fight} from \"../models/Fight\";\nimport {LogLine, LogTypes} from \"../models/LogLine\";\n\nexport const parseLogLine = (logLine: string): LogLine | null => {\n    const DATE_PATTERN = '\\\\d{2}-\\\\d{2}-\\\\d{4}';\n    const TIME_PATTERN = '\\\\d{2}:\\\\d{2}:\\\\d{2}\\\\.\\\\d{3}';\n    const TIMEZONE_PATTERN = '\\\\w+';\n    const ANYTHING_PATTERN = '.*';\n    const ANYTHING_BUT_TAB_PATTERN = '[^\\\\t]*';\n\n    const pattern = new RegExp(`^(${DATE_PATTERN}) (${TIME_PATTERN}) (${TIMEZONE_PATTERN})\\t(${ANYTHING_PATTERN})`);\n\n    let match = logLine.match(pattern);\n\n    if (!match) {\n        console.error('Invalid log line format:', logLine);\n        return null;\n    }\n    const [, date, time, timezone, action] = match;\n\n\n    const logVersionPattern = new RegExp(`Log Version (${ANYTHING_PATTERN})`)\n    match = action.match(logVersionPattern);\n    if (match) {\n        const [, logVersion] = match;\n        console.log(`Log Version ${logVersion}`);\n        return {\n            type: LogTypes.LOG_VERSION,\n            date,\n            time,\n            timezone,\n            logVersion\n        };\n    }\n    const loggedInPlayerPattern = new RegExp(`Logged in player is (${ANYTHING_PATTERN})`)\n    match = action.match(loggedInPlayerPattern);\n    if (match) {\n        const [, loggedInPlayer] = match;\n        return {\n            type: LogTypes.LOGGED_IN_PLAYER,\n            date,\n            time,\n            timezone,\n            loggedInPlayer\n        };\n    }\n\n    const boostedLevelsPattern = new RegExp(`Boosted levels are \\\\[(\\\\d+), (\\\\d+), (\\\\d+), (\\\\d+), (\\\\d+), (\\\\d+), (\\\\d+)\\\\]`);\n    match = action.match(boostedLevelsPattern);\n    if (match) {\n        const [, attack, strength, defence, ranged, magic, hitpoints, prayer] = match.map(Number);\n\n        return {\n            type: LogTypes.BOOSTED_LEVELS,\n            date,\n            time,\n            timezone,\n            boostedLevels: {\n                attack,\n                strength,\n                defence,\n                ranged,\n                magic,\n                hitpoints,\n                prayer\n            }\n        };\n    }\n\n    const playerEquipmentPattern = new RegExp(`Player equipment is (${ANYTHING_PATTERN})`)\n    match = action.match(playerEquipmentPattern);\n    if (match) {\n        const [, equpimentString] = match;\n        const playerEquipment: string[] = JSON.parse(equpimentString).map((item: number) => item.toString());\n        return {\n            type: LogTypes.PLAYER_EQUIPMENT,\n            date,\n            time,\n            timezone,\n            playerEquipment\n        };\n    }\n\n    const diesPattern = new RegExp(`^(${ANYTHING_PATTERN}) dies`)\n    match = action.match(diesPattern);\n    if (match) {\n        const [, target] = match;\n        return {\n            type: LogTypes.DEATH,\n            date,\n            time,\n            timezone,\n            target,\n        };\n    }\n\n    const changedTargetPattern = new RegExp(`^(${ANYTHING_PATTERN}) changes target to (${ANYTHING_PATTERN})`)\n    match = action.match(changedTargetPattern);\n    if (match) {\n        const [, source, target] = match;\n        return {\n            type: LogTypes.TARGET_CHANGE,\n            date,\n            time,\n            timezone,\n            source,\n            target\n        };\n    }\n\n\n    const defaultPattern = new RegExp(`^(${ANYTHING_BUT_TAB_PATTERN})\\t(${ANYTHING_BUT_TAB_PATTERN})\\t(${ANYTHING_BUT_TAB_PATTERN})`);\n\n    match = action.match(defaultPattern);\n    if (!match) {\n        console.error('Invalid log line format:', logLine);\n        return null;\n    }\n    const [, target, hitsplatName, damageAmount] = match;\n\n    return {\n        type: LogTypes.DAMAGE,\n        date,\n        time,\n        timezone,\n        target,\n        hitsplatName,\n        damageAmount: parseInt(damageAmount, 10),\n    };\n};\n\nexport function parseFileContent(fileContent: string, progressCallback: (progress: number) => void): Fight[] | null {\n    try {\n        const lines = fileContent.split('\\n');\n        let parsedLines = 0;\n        let fightData: LogLine[] = [];\n\n        for (const line of lines) {\n            const logLine = parseLogLine(line.trim());\n\n            if (logLine) {\n                fightData.push(logLine);\n            }\n\n            parsedLines++;\n            if (progressCallback && parsedLines % 200 === 0) {\n                const progress = (parsedLines / lines.length) * 50;\n                progressCallback(progress);\n            }\n        }\n\n        let fights: Fight[] = logSplitter(fightData, progressCallback);\n\n        return fights;\n    } catch (error) {\n        console.error('Error parsing file content:', error);\n        return null;\n    }\n}\n\n","import {Fight} from \"../models/Fight\";\nimport {parseFileContent} from \"../utils/FileParser\";\nimport localforage from 'localforage';\n\nconst fightsStorage = localforage.createInstance({\n    name: 'myFightData'\n});\n\nfunction parseFileWithProgress(fileContent: string) {\n    const parseResults = parseFileContent(fileContent, (progress) => {\n        postMessage({type: 'progress', progress});\n    });\n\n    const fightMetadata = parseResults?.map(fight => fight.metaData) || [];\n    const parseResultMessage = {\n        fightMetadata,\n        firstResult: parseResults![0],\n    }\n\n    postMessage({type: 'parseResult', parseResultMessage});\n    fightsStorage.setItem('fightData', parseResults);\n}\n\nfunction getSpecificItem(index: number) {\n    fightsStorage.getItem<Fight[]>('fightData').then((parseResults: Fight[] | null) => {\n        if (parseResults && index >= 0 && index < parseResults.length) {\n            return parseResults[index];\n        }\n        return null;\n    }).then((item) => {\n        postMessage({type: 'item', item});\n    }).catch((error) => {\n        console.error(\"Error getting specific item:\", error);\n    });\n}\n\nonmessage = (event) => {\n    const {type, fileContent, index} = event.data;\n    if (type === 'parse') {\n        parseFileWithProgress(fileContent);\n    } else if (type === 'getItem') {\n        getSpecificItem(index);\n    }\n};\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\tid: moduleId,\n\t\tloaded: false,\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Flag the module as loaded\n\tmodule.loaded = true;\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n// expose the modules object (__webpack_modules__)\n__webpack_require__.m = __webpack_modules__;\n\n// the startup function\n__webpack_require__.x = () => {\n\t// Load entry module and return exports\n\t// This entry module depends on other loaded chunks and execution need to be delayed\n\tvar __webpack_exports__ = __webpack_require__.O(undefined, [200], () => (__webpack_require__(388)))\n\t__webpack_exports__ = __webpack_require__.O(__webpack_exports__);\n\treturn __webpack_exports__;\n};\n\n","var deferred = [];\n__webpack_require__.O = (result, chunkIds, fn, priority) => {\n\tif(chunkIds) {\n\t\tpriority = priority || 0;\n\t\tfor(var i = deferred.length; i > 0 && deferred[i - 1][2] > priority; i--) deferred[i] = deferred[i - 1];\n\t\tdeferred[i] = [chunkIds, fn, priority];\n\t\treturn;\n\t}\n\tvar notFulfilled = Infinity;\n\tfor (var i = 0; i < deferred.length; i++) {\n\t\tvar chunkIds = deferred[i][0];\n\t\tvar fn = deferred[i][1];\n\t\tvar priority = deferred[i][2];\n\t\tvar fulfilled = true;\n\t\tfor (var j = 0; j < chunkIds.length; j++) {\n\t\t\tif ((priority & 1 === 0 || notFulfilled >= priority) && Object.keys(__webpack_require__.O).every((key) => (__webpack_require__.O[key](chunkIds[j])))) {\n\t\t\t\tchunkIds.splice(j--, 1);\n\t\t\t} else {\n\t\t\t\tfulfilled = false;\n\t\t\t\tif(priority < notFulfilled) notFulfilled = priority;\n\t\t\t}\n\t\t}\n\t\tif(fulfilled) {\n\t\t\tdeferred.splice(i--, 1)\n\t\t\tvar r = fn();\n\t\t\tif (r !== undefined) result = r;\n\t\t}\n\t}\n\treturn result;\n};","// getDefaultExport function for compatibility with non-harmony modules\n__webpack_require__.n = (module) => {\n\tvar getter = module && module.__esModule ?\n\t\t() => (module['default']) :\n\t\t() => (module);\n\t__webpack_require__.d(getter, { a: getter });\n\treturn getter;\n};","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.f = {};\n// This file contains only the entry chunk.\n// The chunk loading function for additional chunks\n__webpack_require__.e = (chunkId) => {\n\treturn Promise.all(Object.keys(__webpack_require__.f).reduce((promises, key) => {\n\t\t__webpack_require__.f[key](chunkId, promises);\n\t\treturn promises;\n\t}, []));\n};","// This function allow to reference async chunks and sibling chunks for the entrypoint\n__webpack_require__.u = (chunkId) => {\n\t// return url for filenames based on template\n\treturn \"static/js/\" + chunkId + \".\" + \"d42d81b7\" + \".chunk.js\";\n};","// This function allow to reference async chunks and sibling chunks for the entrypoint\n__webpack_require__.miniCssF = (chunkId) => {\n\t// return url for filenames based on template\n\treturn undefined;\n};","__webpack_require__.g = (function() {\n\tif (typeof globalThis === 'object') return globalThis;\n\ttry {\n\t\treturn this || new Function('return this')();\n\t} catch (e) {\n\t\tif (typeof window === 'object') return window;\n\t}\n})();","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","__webpack_require__.nmd = (module) => {\n\tmodule.paths = [];\n\tif (!module.children) module.children = [];\n\treturn module;\n};","__webpack_require__.p = \"/\";","// no baseURI\n\n// object to store loaded chunks\n// \"1\" means \"already loaded\"\nvar installedChunks = {\n\t388: 1\n};\n\n// importScripts chunk loading\nvar installChunk = (data) => {\n\tvar chunkIds = data[0];\n\tvar moreModules = data[1];\n\tvar runtime = data[2];\n\tfor(var moduleId in moreModules) {\n\t\tif(__webpack_require__.o(moreModules, moduleId)) {\n\t\t\t__webpack_require__.m[moduleId] = moreModules[moduleId];\n\t\t}\n\t}\n\tif(runtime) runtime(__webpack_require__);\n\twhile(chunkIds.length)\n\t\tinstalledChunks[chunkIds.pop()] = 1;\n\tparentChunkLoadingFunction(data);\n};\n__webpack_require__.f.i = (chunkId, promises) => {\n\t// \"1\" is the signal for \"already loaded\"\n\tif(!installedChunks[chunkId]) {\n\t\tif(true) { // all chunks have JS\n\t\t\timportScripts(__webpack_require__.p + __webpack_require__.u(chunkId));\n\t\t}\n\t}\n};\n\nvar chunkLoadingGlobal = self[\"webpackChunkrunelogs\"] = self[\"webpackChunkrunelogs\"] || [];\nvar parentChunkLoadingFunction = chunkLoadingGlobal.push.bind(chunkLoadingGlobal);\nchunkLoadingGlobal.push = installChunk;\n\n// no HMR\n\n// no HMR manifest","var next = __webpack_require__.x;\n__webpack_require__.x = () => {\n\treturn __webpack_require__.e(200).then(next);\n};","// run startup\nvar __webpack_exports__ = __webpack_require__.x();\n"],"names":["LogTypes","DamageMeHitsplats","DamageMaxMeHitsplats","BOSS_NAMES","playerAttemptsDamage","log","Object","values","includes","hitsplatName","bossTargetsMe","player","target","source","parseLogLine","logLine","ANYTHING_PATTERN","ANYTHING_BUT_TAB_PATTERN","pattern","RegExp","concat","match","console","error","date","time","timezone","action","logVersionPattern","logVersion","type","LOG_VERSION","loggedInPlayerPattern","loggedInPlayer","LOGGED_IN_PLAYER","boostedLevelsPattern","attack","strength","defence","ranged","magic","hitpoints","prayer","map","Number","BOOSTED_LEVELS","boostedLevels","playerEquipmentPattern","equpimentString","playerEquipment","JSON","parse","item","toString","PLAYER_EQUIPMENT","diesPattern","DEATH","changedTargetPattern","TARGET_CHANGE","defaultPattern","damageAmount","DAMAGE","parseInt","parseFileContent","fileContent","progressCallback","lines","split","parsedLines","fightData","line","trim","push","length","fights","totalLines","fightStartTime","currentFight","lastDamage","endFight","lastLine","success","nullFight","arguments","undefined","metaData","firstLine","fightLengthMs","fightTimeMs","name","moment","toDate","getTime","data","filter","index","initialData","enemies","logDate","fightNameCounts","Map","fight","some","count","has","get","set","logSplitter","fightsStorage","localforage","onmessage","event","parseResults","progress","postMessage","parseResultMessage","fightMetadata","firstResult","setItem","parseFileWithProgress","getItem","then","catch","getSpecificItem","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","exports","module","id","loaded","__webpack_modules__","call","m","x","__webpack_exports__","O","deferred","result","chunkIds","fn","priority","notFulfilled","Infinity","i","fulfilled","j","keys","every","key","splice","r","n","getter","__esModule","d","a","definition","o","defineProperty","enumerable","f","e","chunkId","Promise","all","reduce","promises","u","miniCssF","g","globalThis","this","Function","window","obj","prop","prototype","hasOwnProperty","nmd","paths","children","p","installedChunks","importScripts","chunkLoadingGlobal","self","parentChunkLoadingFunction","bind","moreModules","runtime","pop","next"],"sourceRoot":""}