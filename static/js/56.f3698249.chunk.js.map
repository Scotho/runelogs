{"version":3,"file":"static/js/56.f3698249.chunk.js","mappings":"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","sources":["HitsplatNames.ts","utils/utils.ts","utils/LogSplitter.ts","utils/FileParser.ts","components/FileParserWorker.ts"],"sourcesContent":["export enum HitsplatNames {\n    POISON = 2,\n    DISEASE = 4,\n    VENOM = 5,\n    HEAL = 6,\n    BLOCK_ME = 12,\n    BLOCK_OTHER = 13,\n    DAMAGE_ME = 16,\n    DAMAGE_OTHER = 17,\n    DAMAGE_ME_CYAN = 18,\n    DAMAGE_OTHER_CYAN = 19,\n    DAMAGE_ME_ORANGE = 20,\n    DAMAGE_OTHER_ORANGE = 21,\n    DAMAGE_ME_YELLOW = 22,\n    DAMAGE_OTHER_YELLOW = 23,\n    DAMAGE_ME_WHITE = 24,\n    DAMAGE_OTHER_WHITE = 25,\n    DAMAGE_MAX_ME = 43,\n    DAMAGE_MAX_ME_CYAN = 44,\n    DAMAGE_MAX_ME_ORANGE = 45,\n    DAMAGE_MAX_ME_YELLOW = 46,\n    DAMAGE_MAX_ME_WHITE = 47,\n    SPLASH_ME = 69,\n}\n\nexport enum DamageMeHitsplats {\n    BLOCK_ME = HitsplatNames.BLOCK_ME,\n    DAMAGE_ME = HitsplatNames.DAMAGE_ME,\n    DAMAGE_ME_CYAN = HitsplatNames.DAMAGE_ME_CYAN,\n    DAMAGE_ME_ORANGE = HitsplatNames.DAMAGE_ME_ORANGE,\n    DAMAGE_ME_YELLOW = HitsplatNames.DAMAGE_ME_YELLOW,\n    DAMAGE_ME_WHITE = HitsplatNames.DAMAGE_ME_WHITE,\n    SPLASH_ME = HitsplatNames.SPLASH_ME,\n}\n\nexport enum DamageMaxMeHitsplats {\n    DAMAGE_MAX_ME = HitsplatNames.DAMAGE_MAX_ME,\n    DAMAGE_MAX_ME_CYAN = HitsplatNames.DAMAGE_MAX_ME_CYAN,\n    DAMAGE_MAX_ME_ORANGE = HitsplatNames.DAMAGE_MAX_ME_ORANGE,\n    DAMAGE_MAX_ME_YELLOW = HitsplatNames.DAMAGE_MAX_ME_YELLOW,\n    DAMAGE_MAX_ME_WHITE = HitsplatNames.DAMAGE_MAX_ME_WHITE,\n}\n\nexport enum DamageOtherHitsplats {\n    BLOCK_OTHER = HitsplatNames.BLOCK_OTHER,\n    DAMAGE_OTHER = HitsplatNames.DAMAGE_OTHER,\n    DAMAGE_OTHER_CYAN = HitsplatNames.DAMAGE_OTHER_CYAN,\n    DAMAGE_OTHER_ORANGE = HitsplatNames.DAMAGE_OTHER_ORANGE,\n    DAMAGE_OTHER_YELLOW = HitsplatNames.DAMAGE_OTHER_YELLOW,\n    DAMAGE_OTHER_WHITE = HitsplatNames.DAMAGE_OTHER_WHITE,\n}\n","import {Fight} from \"../models/Fight\";\nimport {LogLine} from \"../models/LogLine\";\n\nexport function getFightDuration(selectedLog: Fight) {\n    const fightDurationMilliseconds = calculateFightDuration(selectedLog!.data);\n    const duration = new Date(Date.UTC(0, 0, 0, 0, 0, 0, fightDurationMilliseconds));\n    const minutes = duration.getUTCMinutes();\n    const seconds = duration.getUTCSeconds();\n    const milliseconds = duration.getUTCMilliseconds();\n\n    const formattedDuration = `${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}.${milliseconds}`;\n    return formattedDuration;\n}\n\nconst calculateFightDuration = (logs: LogLine[]) => {\n    if (logs.length === 0) {\n        return 0;\n    }\n\n    const startTime = convertTimeToMillis(logs[0].time);\n    const endTime = convertTimeToMillis(logs[logs.length - 1].time);\n\n    return endTime - startTime;\n};\n\nexport const convertTimeToMillis = (time: string): number => {\n    const [hours, minutes, seconds] = time.split(':').map(Number);\n    const milliseconds = hours * 3600000 + minutes * 60000 + seconds * 1000;\n    return milliseconds;\n};","import {LogLine} from \"../models/LogLine\";\nimport {DamageMaxMeHitsplats, DamageMeHitsplats} from \"../HitsplatNames\";\nimport {Fight} from \"../models/Fight\";\nimport {BoostedLevels} from \"../models/BoostedLevels\";\nimport {convertTimeToMillis} from \"./utils\";\n\n\nconst BOSS_NAMES = [\n    \"Scurrius\",\n    \"Kree'arra\",\n    \"Commander Zilyana\",\n    \"General Graardor\",\n    \"K'ril Tsutsaroth\",\n    \"Nex\",\n    \"Kalphite Queen\",\n    \"Sarachnis\",\n    \"Scorpia\",\n    \"Abyssal Sire\"\n];\n\nfunction doesAttemptDamage(log: LogLine) {\n    return Object.values(DamageMeHitsplats).includes(log.hitsplatName!) ||\n        Object.values(DamageMaxMeHitsplats).includes(log.hitsplatName!) ||\n        log.hitsplatName === 'BLOCK_ME';\n}\n\nexport function logSplitter(fightData: LogLine[], progressCallback?: (progress: number) => void): Fight[] {\n    const totalLines = fightData.length;\n    let parsedLines = 0;\n\n    const fights: Fight[] = [];\n    let currentFight: Fight | null = null;\n    let player: string = \"\"; //todo support multiple players\n    let lastDamage: { time: string, index: number } | null = null;\n    let boostedLevels: BoostedLevels;\n\n    for (const logLine of fightData) {\n        if (logLine.loggedInPlayer) {\n            player = logLine.loggedInPlayer;\n        }\n\n        if (logLine.boostedLevels) {\n            boostedLevels = logLine.boostedLevels;\n        }\n\n        // If there's a gap of over 60 seconds end the current fight\n        if (currentFight && lastDamage && convertTimeToMillis(logLine.time) - convertTimeToMillis(lastDamage.time) > 60000) {\n            // eslint-disable-next-line no-loop-func\n            currentFight.data = currentFight.data.filter((log, index) => index <= lastDamage!.index);\n            currentFight.name += \" - Incomplete\";\n            currentFight.lastLine = currentFight.data[currentFight.data.length - 1];\n            fights.push(currentFight);\n            currentFight = null;\n            lastDamage = null;\n        }\n\n        // If the current fight is null, start a new fight\n        if (!currentFight && doesAttemptDamage(logLine) && logLine.target !== player) {\n            currentFight = {\n                name: logLine.target!,\n                enemies: [logLine.target!],\n                data: [\n                    // Include current boosted levels at the beginning of the fight\n                    {\n                        date: logLine.date,\n                        time: logLine.time,\n                        timezone: logLine.timezone,\n                        boostedLevels: boostedLevels!\n                    },\n                    logLine\n                ],\n                loggedInPlayer: player,\n                firstLine: logLine,\n                lastLine: undefined\n            };\n        } else if (currentFight) {\n            // Rename the fight if we encounter a boss in the middle of it\n            if (BOSS_NAMES.includes(logLine.target!) && currentFight.name !== logLine.target) {\n                currentFight.name = logLine.target!;\n            }\n            // Add target to list of enemies\n            if (doesAttemptDamage(logLine) && logLine.target !== player && !currentFight.enemies.includes(logLine.target!)) {\n                currentFight.enemies.push(logLine.target!);\n            }\n            currentFight.data.push(logLine);\n        }\n\n        if (currentFight && doesAttemptDamage(logLine)) {\n            lastDamage = {\n                time: logLine.time,\n                index: currentFight.data.length - 1\n            };\n        }\n\n        if (logLine.target && logLine.hitsplatName === \"DEATH\") {\n            // If the fight name dies, end the current fight\n            if (currentFight && (logLine.target === currentFight.name || logLine.target === currentFight.loggedInPlayer)) {\n                currentFight.lastLine = logLine;\n                fights.push(currentFight);\n                currentFight = null;\n            }\n        }\n\n        parsedLines++;\n        if (progressCallback && parsedLines % 200 === 0) {\n            const progress = 50 + (parsedLines / totalLines) * 50;\n            progressCallback(progress);\n        }\n    }\n\n    // If we reach the end of the logs, end the current fight\n    if (currentFight) {\n        currentFight.lastLine = currentFight.data[currentFight.data.length - 1];\n        fights.push(currentFight);\n    }\n\n    // Filter out fights with no damage\n    return fights.filter((fight) => fight.data.some((log) =>\n        doesAttemptDamage(log)\n    ));\n}\n","import {logSplitter} from \"./LogSplitter\";\nimport {Fight} from \"../models/Fight\";\nimport {LogLine} from \"../models/LogLine\";\nimport {BoostedLevels} from \"../models/BoostedLevels\";\n\nexport const parseLogLine = (logLine: string): LogLine | null => {\n    const DATE_PATTERN = '\\\\d{2}-\\\\d{2}-\\\\d{4}';\n    const TIME_PATTERN = '\\\\d{2}:\\\\d{2}:\\\\d{2}\\\\.\\\\d{3}';\n    const TIMEZONE_PATTERN = '\\\\w+';\n    const ANYTHING_PATTERN = '.*';\n    const ANYTHING_BUT_TAB_PATTERN = '[^\\\\t]*';\n\n    const pattern = new RegExp(`^(${DATE_PATTERN}) (${TIME_PATTERN}) (${TIMEZONE_PATTERN})\\t(${ANYTHING_PATTERN})`);\n\n    let match = logLine.match(pattern);\n\n    if (!match) {\n        console.error('Invalid log line format:', logLine);\n        return null;\n    }\n    const [, date, time, timezone, action] = match;\n\n\n    const logVersionPattern = new RegExp(`Log Version (${ANYTHING_PATTERN})`)\n    match = action.match(logVersionPattern);\n    if (match) {\n        const [, logVersion] = match;\n        console.log(`Log Version ${logVersion}`);\n        return {\n            date,\n            time,\n            timezone,\n            logVersion\n        };\n    }\n    const loggedInPlayerPattern = new RegExp(`Logged in player is (${ANYTHING_PATTERN})`)\n    match = action.match(loggedInPlayerPattern);\n    if (match) {\n        const [, loggedInPlayer] = match;\n        return {\n            date,\n            time,\n            timezone,\n            loggedInPlayer\n        };\n    }\n\n    const boostedLevelsPattern = new RegExp(`Boosted levels are \\\\[(\\\\d+), (\\\\d+), (\\\\d+), (\\\\d+), (\\\\d+), (\\\\d+), (\\\\d+)\\\\]`);\n    match = action.match(boostedLevelsPattern);\n    if (match) {\n        const [, attack, strength, defence, ranged, magic, hitpoints, prayer] = match.map(Number);\n\n        const boostedLevels: BoostedLevels = {\n            attack,\n            strength,\n            defence,\n            ranged,\n            magic,\n            hitpoints,\n            prayer\n        };\n\n        return {\n            date,\n            time,\n            timezone,\n            boostedLevels\n        };\n    }\n\n    const playerEquipmentPattern = new RegExp(`Player equipment is (${ANYTHING_PATTERN})`)\n    match = action.match(playerEquipmentPattern);\n    if (match) {\n        const [, playerEquipment] = match;\n        return {\n            date,\n            time,\n            timezone,\n            playerEquipment\n        };\n    }\n\n    const diesPattern = new RegExp(`^(${ANYTHING_PATTERN}) dies`)\n    match = action.match(diesPattern);\n    if (match) {\n        const [, target] = match;\n        return {\n            date,\n            time,\n            timezone,\n            target,\n            hitsplatName: \"DEATH\",\n        };\n    }\n\n    const changedTargetPattern = new RegExp(`^(${ANYTHING_PATTERN}) changes target to (${ANYTHING_PATTERN})`)\n    match = action.match(changedTargetPattern);\n    if (match) {\n        const [, source, target] = match;\n        return {\n            date,\n            time,\n            timezone,\n            source,\n            target,\n            hitsplatName: \"CHANGE_TARGET\",\n        };\n    }\n\n\n    const defaultPattern = new RegExp(`^(${ANYTHING_BUT_TAB_PATTERN})\\t(${ANYTHING_BUT_TAB_PATTERN})\\t(${ANYTHING_BUT_TAB_PATTERN})`);\n\n    match = action.match(defaultPattern);\n    if (!match) {\n        console.error('Invalid log line format:', logLine);\n        return null;\n    }\n    const [, target, hitsplatName, damageAmount] = match;\n\n    return {\n        date,\n        time,\n        timezone,\n        target,\n        hitsplatName,\n        damageAmount: parseInt(damageAmount, 10),\n    };\n};\n\nexport function parseFileContent(fileContent: string, progressCallback: (progress: number) => void): Fight[] | null {\n    try {\n        const lines = fileContent.split('\\n');\n        let parsedLines = 0;\n        let fightData: LogLine[] = [];\n\n        for (const line of lines) {\n            const logLine = parseLogLine(line.trim());\n\n            if (logLine) {\n                fightData.push(logLine);\n            }\n\n            parsedLines++;\n            if (progressCallback && parsedLines % 200 === 0) {\n                const progress = (parsedLines / lines.length) * 50;\n                progressCallback(progress);\n            }\n        }\n\n        let fights: Fight[] = logSplitter(fightData, progressCallback);\n\n        return fights;\n    } catch (error) {\n        console.error('Error parsing file content:', error);\n        return null;\n    }\n}\n\n","import {Fight} from \"../models/Fight\";\nimport {parseFileContent} from \"../utils/FileParser\";\n\nlet parseResults: Fight[] | null = null;\n\nfunction parseFileWithProgress(fileContent: string) {\n    parseResults = parseFileContent(fileContent, (progress) => {\n        postMessage({type: 'progress', progress});\n    });\n\n    const fightNames = parseResults?.map(fight => fight.name) || [];\n    const parseResultMessage = {\n        fightNames,\n        firstResult: parseResults![0],\n    }\n    postMessage({type: 'parseResult', parseResultMessage});\n}\n\nfunction getSpecificItem(index: number) {\n    if (parseResults && index >= 0 && index < parseResults.length) {\n        return parseResults[index];\n    }\n    return null;\n}\n\nonmessage = (event) => {\n    const {type, fileContent, index} = event.data;\n    if (type === 'parse') {\n        parseFileWithProgress(fileContent);\n    } else if (type === 'getItem') {\n        const item = getSpecificItem(index);\n        postMessage({type: 'item', item});\n    }\n};\n"],"names":["DamageMeHitsplats","DamageMaxMeHitsplats","convertTimeToMillis","time","hours","minutes","seconds","split","map","Number","BOSS_NAMES","doesAttemptDamage","log","Object","values","includes","hitsplatName","parseLogLine","logLine","ANYTHING_PATTERN","ANYTHING_BUT_TAB_PATTERN","pattern","RegExp","concat","match","console","error","date","timezone","action","logVersionPattern","logVersion","loggedInPlayerPattern","loggedInPlayer","boostedLevelsPattern","attack","strength","defence","ranged","magic","hitpoints","prayer","boostedLevels","playerEquipmentPattern","playerEquipment","diesPattern","target","changedTargetPattern","source","defaultPattern","damageAmount","parseInt","parseFileContent","fileContent","progressCallback","lines","parsedLines","fightData","line","trim","push","length","fights","totalLines","currentFight","player","lastDamage","data","filter","index","name","lastLine","enemies","firstLine","undefined","fight","some","logSplitter","parseResults","onmessage","event","type","_parseResults","progress","postMessage","parseResultMessage","fightNames","firstResult","parseFileWithProgress","item","getSpecificItem"],"sourceRoot":""}