{"version":3,"file":"static/js/220.0bda8cf8.chunk.js","mappings":"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","sources":["models/LogLine.ts","HitsplatNames.ts","utils/utils.ts","utils/LogSplitter.ts","utils/FileParser.ts","components/FileParserWorker.ts","../webpack/bootstrap","../webpack/runtime/chunk loaded","../webpack/runtime/compat get default export","../webpack/runtime/define property getters","../webpack/runtime/ensure chunk","../webpack/runtime/get javascript chunk filename","../webpack/runtime/get mini-css chunk filename","../webpack/runtime/global","../webpack/runtime/hasOwnProperty shorthand","../webpack/runtime/publicPath","../webpack/runtime/importScripts chunk loading","../webpack/runtime/startup chunk dependencies","../webpack/startup"],"sourcesContent":["import {BoostedLevels} from \"./BoostedLevels\";\n\nexport enum LogTypes {\n    LOG_VERSION = 'Log Version',\n    LOGGED_IN_PLAYER = 'Logged In Player',\n    BOOSTED_LEVELS = 'Boosted Levels',\n    PLAYER_EQUIPMENT = 'Player Equipment',\n    DEATH = 'Death',\n    TARGET_CHANGE = 'Target Change',\n    DAMAGE = 'Damage'\n}\n\nexport interface BaseLog {\n    date: string;\n    time: string;\n    timezone: string;\n    fightTime?: string;\n}\n\nexport interface LogVersionLog extends BaseLog {\n    type: LogTypes.LOG_VERSION;\n    logVersion: string;\n}\n\n\nexport interface LoggedInPlayerLog extends BaseLog {\n    type: LogTypes.LOGGED_IN_PLAYER;\n    loggedInPlayer: string;\n}\n\nexport interface BoostedLevelsLog extends BaseLog {\n    type: LogTypes.BOOSTED_LEVELS;\n    boostedLevels: BoostedLevels;\n}\n\nexport interface PlayerEquipmentLog extends BaseLog {\n    type: LogTypes.PLAYER_EQUIPMENT;\n    playerEquipment: string[];\n}\n\nexport interface DeathLog extends BaseLog {\n    type: LogTypes.DEATH;\n    target: string;\n}\n\nexport interface TargetChangeLog extends BaseLog {\n    type: LogTypes.TARGET_CHANGE;\n    source: string;\n    target: string;\n}\n\nexport interface DamageLog extends BaseLog {\n    type: LogTypes.DAMAGE;\n    target: string;\n    hitsplatName: string;\n    damageAmount: number;\n}\n\nexport type LogLine =\n    LogVersionLog\n    | LoggedInPlayerLog\n    | BoostedLevelsLog\n    | PlayerEquipmentLog\n    | DeathLog\n    | TargetChangeLog\n    | DamageLog;\n\nexport function filterByType<T extends LogLine['type']>(logs: LogLine[], type: T): Extract<LogLine, { type: T }>[] {\n    return logs.filter(log => log.type === type) as Extract<LogLine, { type: T }>[];\n}\n\n","export enum HitsplatNames {\n    POISON = 2,\n    DISEASE = 4,\n    VENOM = 5,\n    HEAL = 6,\n    BLOCK_ME = 12,\n    BLOCK_OTHER = 13,\n    DAMAGE_ME = 16,\n    DAMAGE_OTHER = 17,\n    DAMAGE_ME_CYAN = 18,\n    DAMAGE_OTHER_CYAN = 19,\n    DAMAGE_ME_ORANGE = 20,\n    DAMAGE_OTHER_ORANGE = 21,\n    DAMAGE_ME_YELLOW = 22,\n    DAMAGE_OTHER_YELLOW = 23,\n    DAMAGE_ME_WHITE = 24,\n    DAMAGE_OTHER_WHITE = 25,\n    DAMAGE_MAX_ME = 43,\n    DAMAGE_MAX_ME_CYAN = 44,\n    DAMAGE_MAX_ME_ORANGE = 45,\n    DAMAGE_MAX_ME_YELLOW = 46,\n    DAMAGE_MAX_ME_WHITE = 47,\n    SPLASH_ME = 69,\n}\n\nexport enum DamageMeHitsplats {\n    BLOCK_ME = HitsplatNames.BLOCK_ME,\n    DAMAGE_ME = HitsplatNames.DAMAGE_ME,\n    DAMAGE_ME_CYAN = HitsplatNames.DAMAGE_ME_CYAN,\n    DAMAGE_ME_ORANGE = HitsplatNames.DAMAGE_ME_ORANGE,\n    DAMAGE_ME_YELLOW = HitsplatNames.DAMAGE_ME_YELLOW,\n    DAMAGE_ME_WHITE = HitsplatNames.DAMAGE_ME_WHITE,\n    SPLASH_ME = HitsplatNames.SPLASH_ME,\n}\n\nexport enum DamageMaxMeHitsplats {\n    DAMAGE_MAX_ME = HitsplatNames.DAMAGE_MAX_ME,\n    DAMAGE_MAX_ME_CYAN = HitsplatNames.DAMAGE_MAX_ME_CYAN,\n    DAMAGE_MAX_ME_ORANGE = HitsplatNames.DAMAGE_MAX_ME_ORANGE,\n    DAMAGE_MAX_ME_YELLOW = HitsplatNames.DAMAGE_MAX_ME_YELLOW,\n    DAMAGE_MAX_ME_WHITE = HitsplatNames.DAMAGE_MAX_ME_WHITE,\n}\n\nexport enum DamageOtherHitsplats {\n    BLOCK_OTHER = HitsplatNames.BLOCK_OTHER,\n    DAMAGE_OTHER = HitsplatNames.DAMAGE_OTHER,\n    DAMAGE_OTHER_CYAN = HitsplatNames.DAMAGE_OTHER_CYAN,\n    DAMAGE_OTHER_ORANGE = HitsplatNames.DAMAGE_OTHER_ORANGE,\n    DAMAGE_OTHER_YELLOW = HitsplatNames.DAMAGE_OTHER_YELLOW,\n    DAMAGE_OTHER_WHITE = HitsplatNames.DAMAGE_OTHER_WHITE,\n}\n","import {Fight} from \"../models/Fight\";\nimport {LogLine, LogTypes} from \"../models/LogLine\";\n\nexport function getFightDuration(selectedLog: Fight) {\n    const fightDurationMilliseconds = calculateFightDuration(selectedLog!);\n    const duration = new Date(Date.UTC(0, 0, 0, 0, 0, 0, fightDurationMilliseconds));\n    const minutes = duration.getUTCMinutes();\n    const seconds = duration.getUTCSeconds();\n    const milliseconds = duration.getUTCMilliseconds();\n\n    const formattedDuration = `${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}.${milliseconds}`;\n    return formattedDuration;\n}\n\nconst calculateFightDuration = (fight: Fight) => {\n    if (fight.data.length === 0) {\n        return 0;\n    }\n\n    const startTime = convertTimeToMillis(fight.firstLine.time);\n    const endTime = convertTimeToMillis(fight.lastLine.time);\n\n    return endTime - startTime;\n};\n\nexport function calculateAccuracy(fight: Fight) {\n    const hitsplatsCount = fight.data.filter(log => log.type === LogTypes.DAMAGE).length;\n    const successfulHitsplatsCount = fight.data.filter(log => log.type === LogTypes.DAMAGE && (log as LogLine & {\n        type: LogTypes.DAMAGE\n    }).damageAmount > 0).length;\n    const accuracyPercentage = hitsplatsCount > 0 ? (successfulHitsplatsCount / hitsplatsCount) * 100 : 0;\n    return accuracyPercentage;\n}\n\nexport const convertTimeToMillis = (time: string): number => {\n    const [hours, minutes, seconds] = time.split(':').map(Number);\n    const milliseconds = hours * 3600000 + minutes * 60000 + seconds * 1000;\n    return milliseconds;\n};\n\nexport function convertMillisToTime(duration: number): string {\n    const milliseconds = Math.floor(duration % 1000);\n    let seconds: any = Math.floor((duration / 1000) % 60);\n    let minutes: any = Math.floor((duration / (1000 * 60)) % 60);\n    let hours: any = Math.floor((duration / (1000 * 60 * 60)) % 24);\n\n    hours = (hours < 10) ? \"0\" + hours : hours;\n    minutes = (minutes < 10) ? \"0\" + minutes : minutes;\n    seconds = (seconds < 10) ? \"0\" + seconds : seconds;\n\n    const formattedMilliseconds = (milliseconds < 10) ? \"00\" + milliseconds : (milliseconds < 100) ? \"0\" + milliseconds : milliseconds;\n\n    return hours + \":\" + minutes + \":\" + seconds + \".\" + formattedMilliseconds;\n}","import {DamageLog, LogLine, LogTypes} from \"../models/LogLine\";\nimport {DamageMaxMeHitsplats, DamageMeHitsplats} from \"../HitsplatNames\";\nimport {Fight} from \"../models/Fight\";\nimport {BoostedLevels} from \"../models/BoostedLevels\";\nimport {convertMillisToTime, convertTimeToMillis} from \"./utils\";\n\n\nconst BOSS_NAMES = [\n    \"Scurrius\",\n    \"Kree'arra\",\n    \"Commander Zilyana\",\n    \"General Graardor\",\n    \"K'ril Tsutsaroth\",\n    \"Nex\",\n    \"Kalphite Queen\",\n    \"Sarachnis\",\n    \"Scorpia\",\n    \"Abyssal Sire\",\n    \"Kraken\"\n];\n\n/**\n * If it is the logged in player that dealt/attempted the damage\n */\nfunction playerAttemptsDamage(log: DamageLog) {\n    return Object.values(DamageMeHitsplats).includes(log.hitsplatName!) ||\n        Object.values(DamageMaxMeHitsplats).includes(log.hitsplatName!) ||\n        log.hitsplatName === 'BLOCK_ME';\n}\n\nexport function logSplitter(fightData: LogLine[], progressCallback?: (progress: number) => void): Fight[] {\n    const totalLines = fightData.length;\n    let parsedLines = 0;\n\n    const fights: Fight[] = [];\n    let currentFight: Fight | null = null;\n    let player: string = \"\"; //todo support multiple players\n    let lastDamage: { time: string, index: number } | null = null;\n    let boostedLevels: BoostedLevels | undefined;\n    let playerEquipment: string[] | undefined;\n    let fightStartTime: Date;\n\n    for (const logLine of fightData) {\n        if (logLine.type === LogTypes.LOGGED_IN_PLAYER) {\n            player = logLine.loggedInPlayer;\n        }\n\n        if (logLine.type === LogTypes.BOOSTED_LEVELS) {\n            boostedLevels = logLine.boostedLevels;\n        }\n\n        if (logLine.type === LogTypes.PLAYER_EQUIPMENT) {\n            playerEquipment = logLine.playerEquipment;\n        }\n\n        // If there's a gap of over 60 seconds end the current fight\n        if (currentFight && lastDamage && convertTimeToMillis(logLine.time) - convertTimeToMillis(lastDamage.time) > 60000) {\n            // eslint-disable-next-line no-loop-func\n            currentFight.data = currentFight.data.filter((log, index) => index <= lastDamage!.index);\n            currentFight.name += \" - Incomplete\";\n            currentFight.lastLine = currentFight.data[currentFight.data.length - 1];\n            fights.push(currentFight);\n            currentFight = null;\n            lastDamage = null;\n        }\n\n        // If the current fight is null, start a new fight\n        if (!currentFight && logLine.type === LogTypes.DAMAGE && playerAttemptsDamage(logLine) && logLine.target !== player) {\n            fightStartTime = new Date(logLine.date + \" \" + logLine.time);\n            logLine.fightTime = convertMillisToTime(0);\n\n            const initialData: LogLine[] = [];\n\n            // Include current boosted levels at the beginning of the fight\n            if (boostedLevels) {\n                initialData.push({\n                    type: LogTypes.BOOSTED_LEVELS,\n                    date: logLine.date,\n                    time: logLine.time,\n                    timezone: logLine.timezone,\n                    boostedLevels: boostedLevels,\n                    fightTime: convertMillisToTime(0)\n                });\n            }\n\n            // Include current player equipment at the beginning of the fight\n            if (playerEquipment) {\n                initialData.push({\n                    type: LogTypes.PLAYER_EQUIPMENT,\n                    date: logLine.date,\n                    time: logLine.time,\n                    timezone: logLine.timezone,\n                    playerEquipment: playerEquipment,\n                    fightTime: convertMillisToTime(0)\n                });\n            }\n\n            currentFight = {\n                name: logLine.target,\n                enemies: [logLine.target],\n                data: [\n                    ...initialData,\n                    logLine\n                ],\n                loggedInPlayer: player,\n                firstLine: logLine,\n                lastLine: logLine\n            };\n        } else if (currentFight) {\n            // Rename the fight if we encounter a boss in the middle of it\n            if (\"target\" in logLine && BOSS_NAMES.includes(logLine.target!) && currentFight.name !== logLine.target) {\n                currentFight.name = logLine.target!;\n            }\n            // Add target to list of enemies\n            if (logLine.type === LogTypes.DAMAGE && playerAttemptsDamage(logLine) && logLine.target !== player && !currentFight.enemies.includes(logLine.target!)) {\n                currentFight.enemies.push(logLine.target!);\n            }\n\n            // Subtract the start time from the log's timestamp to get the relative time within the fight\n            const logDate = new Date(logLine.date + \" \" + logLine.time);\n            logLine.fightTime = convertMillisToTime(logDate.getTime() - fightStartTime!.getTime());\n\n            currentFight.data.push(logLine);\n        }\n\n        if (currentFight && logLine.type === LogTypes.DAMAGE && playerAttemptsDamage(logLine)) {\n            lastDamage = {\n                time: logLine.time,\n                index: currentFight.data.length - 1\n            };\n        }\n\n        if (logLine.type === LogTypes.DEATH && logLine.target) {\n            // If the fight name dies, end the current fight\n            if (currentFight && (logLine.target === currentFight.name || logLine.target === currentFight.loggedInPlayer)) {\n                currentFight.lastLine = logLine;\n                fights.push(currentFight);\n                currentFight = null;\n            }\n        }\n\n        parsedLines++;\n        if (progressCallback && parsedLines % 200 === 0) {\n            const progress = 50 + (parsedLines / totalLines) * 50;\n            progressCallback(progress);\n        }\n    }\n\n    // If we reach the end of the logs, end the current fight\n    if (currentFight) {\n        currentFight.lastLine = currentFight.data[currentFight.data.length - 1];\n        fights.push(currentFight);\n    }\n\n    const fightNameCounts: Map<string, number> = new Map(); // Map to store counts of each fight name\n\n    const filteredFights = fights.filter((fight) => {\n        // If the fight has no damage logs from the player, discard it\n        const hasPlayerDamage = fight.data.some((logLine) =>\n            logLine.type === LogTypes.DAMAGE && playerAttemptsDamage(logLine)\n        );\n        if (!hasPlayerDamage) {\n            return false;\n        }\n\n        // Make fight names unique\n        let count = 1;\n        if (fightNameCounts.has(fight.name)) {\n            count = fightNameCounts.get(fight.name)! + 1;\n        }\n        fightNameCounts.set(fight.name, count);\n        fight.name = `${fight.name} - ${count}`;\n\n        return true;\n    });\n\n    return filteredFights;\n}\n","import {logSplitter} from \"./LogSplitter\";\nimport {Fight} from \"../models/Fight\";\nimport {LogLine, LogTypes} from \"../models/LogLine\";\n\nexport const parseLogLine = (logLine: string): LogLine | null => {\n    const DATE_PATTERN = '\\\\d{2}-\\\\d{2}-\\\\d{4}';\n    const TIME_PATTERN = '\\\\d{2}:\\\\d{2}:\\\\d{2}\\\\.\\\\d{3}';\n    const TIMEZONE_PATTERN = '\\\\w+';\n    const ANYTHING_PATTERN = '.*';\n    const ANYTHING_BUT_TAB_PATTERN = '[^\\\\t]*';\n\n    const pattern = new RegExp(`^(${DATE_PATTERN}) (${TIME_PATTERN}) (${TIMEZONE_PATTERN})\\t(${ANYTHING_PATTERN})`);\n\n    let match = logLine.match(pattern);\n\n    if (!match) {\n        console.error('Invalid log line format:', logLine);\n        return null;\n    }\n    const [, date, time, timezone, action] = match;\n\n\n    const logVersionPattern = new RegExp(`Log Version (${ANYTHING_PATTERN})`)\n    match = action.match(logVersionPattern);\n    if (match) {\n        const [, logVersion] = match;\n        console.log(`Log Version ${logVersion}`);\n        return {\n            type: LogTypes.LOG_VERSION,\n            date,\n            time,\n            timezone,\n            logVersion\n        };\n    }\n    const loggedInPlayerPattern = new RegExp(`Logged in player is (${ANYTHING_PATTERN})`)\n    match = action.match(loggedInPlayerPattern);\n    if (match) {\n        const [, loggedInPlayer] = match;\n        return {\n            type: LogTypes.LOGGED_IN_PLAYER,\n            date,\n            time,\n            timezone,\n            loggedInPlayer\n        };\n    }\n\n    const boostedLevelsPattern = new RegExp(`Boosted levels are \\\\[(\\\\d+), (\\\\d+), (\\\\d+), (\\\\d+), (\\\\d+), (\\\\d+), (\\\\d+)\\\\]`);\n    match = action.match(boostedLevelsPattern);\n    if (match) {\n        const [, attack, strength, defence, ranged, magic, hitpoints, prayer] = match.map(Number);\n\n        return {\n            type: LogTypes.BOOSTED_LEVELS,\n            date,\n            time,\n            timezone,\n            boostedLevels: {\n                attack,\n                strength,\n                defence,\n                ranged,\n                magic,\n                hitpoints,\n                prayer\n            }\n        };\n    }\n\n    const playerEquipmentPattern = new RegExp(`Player equipment is (${ANYTHING_PATTERN})`)\n    match = action.match(playerEquipmentPattern);\n    if (match) {\n        const [, equpimentString] = match;\n        const playerEquipment: string[] = JSON.parse(equpimentString).map((item: number) => item.toString());\n        return {\n            type: LogTypes.PLAYER_EQUIPMENT,\n            date,\n            time,\n            timezone,\n            playerEquipment\n        };\n    }\n\n    const diesPattern = new RegExp(`^(${ANYTHING_PATTERN}) dies`)\n    match = action.match(diesPattern);\n    if (match) {\n        const [, target] = match;\n        return {\n            type: LogTypes.DEATH,\n            date,\n            time,\n            timezone,\n            target,\n        };\n    }\n\n    const changedTargetPattern = new RegExp(`^(${ANYTHING_PATTERN}) changes target to (${ANYTHING_PATTERN})`)\n    match = action.match(changedTargetPattern);\n    if (match) {\n        const [, source, target] = match;\n        return {\n            type: LogTypes.TARGET_CHANGE,\n            date,\n            time,\n            timezone,\n            source,\n            target\n        };\n    }\n\n\n    const defaultPattern = new RegExp(`^(${ANYTHING_BUT_TAB_PATTERN})\\t(${ANYTHING_BUT_TAB_PATTERN})\\t(${ANYTHING_BUT_TAB_PATTERN})`);\n\n    match = action.match(defaultPattern);\n    if (!match) {\n        console.error('Invalid log line format:', logLine);\n        return null;\n    }\n    const [, target, hitsplatName, damageAmount] = match;\n\n    return {\n        type: LogTypes.DAMAGE,\n        date,\n        time,\n        timezone,\n        target,\n        hitsplatName,\n        damageAmount: parseInt(damageAmount, 10),\n    };\n};\n\nexport function parseFileContent(fileContent: string, progressCallback: (progress: number) => void): Fight[] | null {\n    try {\n        const lines = fileContent.split('\\n');\n        let parsedLines = 0;\n        let fightData: LogLine[] = [];\n\n        for (const line of lines) {\n            const logLine = parseLogLine(line.trim());\n\n            if (logLine) {\n                fightData.push(logLine);\n            }\n\n            parsedLines++;\n            if (progressCallback && parsedLines % 200 === 0) {\n                const progress = (parsedLines / lines.length) * 50;\n                progressCallback(progress);\n            }\n        }\n\n        let fights: Fight[] = logSplitter(fightData, progressCallback);\n\n        return fights;\n    } catch (error) {\n        console.error('Error parsing file content:', error);\n        return null;\n    }\n}\n\n","import {Fight} from \"../models/Fight\";\nimport {parseFileContent} from \"../utils/FileParser\";\nimport localforage from 'localforage';\n\nconst fightsStorage = localforage.createInstance({\n    name: 'myFightData'\n});\n\nfunction parseFileWithProgress(fileContent: string) {\n    const parseResults = parseFileContent(fileContent, (progress) => {\n        postMessage({type: 'progress', progress});\n    });\n\n    const fightNames = parseResults?.map(fight => fight.name) || [];\n    const parseResultMessage = {\n        fightNames,\n        firstResult: parseResults![0],\n    }\n\n    postMessage({type: 'parseResult', parseResultMessage});\n    fightsStorage.setItem('fightData', parseResults);\n}\n\nfunction getSpecificItem(index: number) {\n    fightsStorage.getItem<Fight[]>('fightData').then((parseResults: Fight[] | null) => {\n        if (parseResults && index >= 0 && index < parseResults.length) {\n            return parseResults[index];\n        }\n        return null;\n    }).then((item) => {\n        postMessage({type: 'item', item});\n    }).catch((error) => {\n        console.error(\"Error getting specific item:\", error);\n    });\n}\n\nonmessage = (event) => {\n    const {type, fileContent, index} = event.data;\n    if (type === 'parse') {\n        parseFileWithProgress(fileContent);\n    } else if (type === 'getItem') {\n        getSpecificItem(index);\n    }\n};\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n// expose the modules object (__webpack_modules__)\n__webpack_require__.m = __webpack_modules__;\n\n// the startup function\n__webpack_require__.x = () => {\n\t// Load entry module and return exports\n\t// This entry module depends on other loaded chunks and execution need to be delayed\n\tvar __webpack_exports__ = __webpack_require__.O(undefined, [340], () => (__webpack_require__(3839)))\n\t__webpack_exports__ = __webpack_require__.O(__webpack_exports__);\n\treturn __webpack_exports__;\n};\n\n","var deferred = [];\n__webpack_require__.O = (result, chunkIds, fn, priority) => {\n\tif(chunkIds) {\n\t\tpriority = priority || 0;\n\t\tfor(var i = deferred.length; i > 0 && deferred[i - 1][2] > priority; i--) deferred[i] = deferred[i - 1];\n\t\tdeferred[i] = [chunkIds, fn, priority];\n\t\treturn;\n\t}\n\tvar notFulfilled = Infinity;\n\tfor (var i = 0; i < deferred.length; i++) {\n\t\tvar chunkIds = deferred[i][0];\n\t\tvar fn = deferred[i][1];\n\t\tvar priority = deferred[i][2];\n\t\tvar fulfilled = true;\n\t\tfor (var j = 0; j < chunkIds.length; j++) {\n\t\t\tif ((priority & 1 === 0 || notFulfilled >= priority) && Object.keys(__webpack_require__.O).every((key) => (__webpack_require__.O[key](chunkIds[j])))) {\n\t\t\t\tchunkIds.splice(j--, 1);\n\t\t\t} else {\n\t\t\t\tfulfilled = false;\n\t\t\t\tif(priority < notFulfilled) notFulfilled = priority;\n\t\t\t}\n\t\t}\n\t\tif(fulfilled) {\n\t\t\tdeferred.splice(i--, 1)\n\t\t\tvar r = fn();\n\t\t\tif (r !== undefined) result = r;\n\t\t}\n\t}\n\treturn result;\n};","// getDefaultExport function for compatibility with non-harmony modules\n__webpack_require__.n = (module) => {\n\tvar getter = module && module.__esModule ?\n\t\t() => (module['default']) :\n\t\t() => (module);\n\t__webpack_require__.d(getter, { a: getter });\n\treturn getter;\n};","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.f = {};\n// This file contains only the entry chunk.\n// The chunk loading function for additional chunks\n__webpack_require__.e = (chunkId) => {\n\treturn Promise.all(Object.keys(__webpack_require__.f).reduce((promises, key) => {\n\t\t__webpack_require__.f[key](chunkId, promises);\n\t\treturn promises;\n\t}, []));\n};","// This function allow to reference async chunks and sibling chunks for the entrypoint\n__webpack_require__.u = (chunkId) => {\n\t// return url for filenames based on template\n\treturn \"static/js/\" + chunkId + \".\" + \"5989bce5\" + \".chunk.js\";\n};","// This function allow to reference async chunks and sibling chunks for the entrypoint\n__webpack_require__.miniCssF = (chunkId) => {\n\t// return url for filenames based on template\n\treturn undefined;\n};","__webpack_require__.g = (function() {\n\tif (typeof globalThis === 'object') return globalThis;\n\ttry {\n\t\treturn this || new Function('return this')();\n\t} catch (e) {\n\t\tif (typeof window === 'object') return window;\n\t}\n})();","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","__webpack_require__.p = \"/\";","// no baseURI\n\n// object to store loaded chunks\n// \"1\" means \"already loaded\"\nvar installedChunks = {\n\t220: 1\n};\n\n// importScripts chunk loading\nvar installChunk = (data) => {\n\tvar chunkIds = data[0];\n\tvar moreModules = data[1];\n\tvar runtime = data[2];\n\tfor(var moduleId in moreModules) {\n\t\tif(__webpack_require__.o(moreModules, moduleId)) {\n\t\t\t__webpack_require__.m[moduleId] = moreModules[moduleId];\n\t\t}\n\t}\n\tif(runtime) runtime(__webpack_require__);\n\twhile(chunkIds.length)\n\t\tinstalledChunks[chunkIds.pop()] = 1;\n\tparentChunkLoadingFunction(data);\n};\n__webpack_require__.f.i = (chunkId, promises) => {\n\t// \"1\" is the signal for \"already loaded\"\n\tif(!installedChunks[chunkId]) {\n\t\tif(true) { // all chunks have JS\n\t\t\timportScripts(__webpack_require__.p + __webpack_require__.u(chunkId));\n\t\t}\n\t}\n};\n\nvar chunkLoadingGlobal = self[\"webpackChunkrunelogs\"] = self[\"webpackChunkrunelogs\"] || [];\nvar parentChunkLoadingFunction = chunkLoadingGlobal.push.bind(chunkLoadingGlobal);\nchunkLoadingGlobal.push = installChunk;\n\n// no HMR\n\n// no HMR manifest","var next = __webpack_require__.x;\n__webpack_require__.x = () => {\n\treturn __webpack_require__.e(340).then(next);\n};","// run startup\nvar __webpack_exports__ = __webpack_require__.x();\n"],"names":["LogTypes","DamageMeHitsplats","DamageMaxMeHitsplats","convertTimeToMillis","time","hours","minutes","seconds","split","map","Number","convertMillisToTime","duration","milliseconds","Math","floor","BOSS_NAMES","playerAttemptsDamage","log","Object","values","includes","hitsplatName","parseLogLine","logLine","ANYTHING_PATTERN","ANYTHING_BUT_TAB_PATTERN","pattern","RegExp","concat","match","console","error","date","timezone","action","logVersionPattern","logVersion","type","LOG_VERSION","loggedInPlayerPattern","loggedInPlayer","LOGGED_IN_PLAYER","boostedLevelsPattern","attack","strength","defence","ranged","magic","hitpoints","prayer","BOOSTED_LEVELS","boostedLevels","playerEquipmentPattern","equpimentString","playerEquipment","JSON","parse","item","toString","PLAYER_EQUIPMENT","diesPattern","target","DEATH","changedTargetPattern","source","TARGET_CHANGE","defaultPattern","damageAmount","DAMAGE","parseInt","parseFileContent","fileContent","progressCallback","lines","parsedLines","fightData","line","trim","push","length","fights","totalLines","fightStartTime","currentFight","player","lastDamage","data","filter","index","name","lastLine","Date","fightTime","initialData","enemies","firstLine","logDate","getTime","fightNameCounts","Map","fight","some","count","has","get","set","logSplitter","fightsStorage","localforage","onmessage","event","parseResults","progress","postMessage","parseResultMessage","fightNames","firstResult","setItem","parseFileWithProgress","getItem","then","catch","getSpecificItem","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","undefined","exports","module","__webpack_modules__","m","x","__webpack_exports__","O","deferred","result","chunkIds","fn","priority","notFulfilled","Infinity","i","fulfilled","j","keys","every","key","splice","r","n","getter","__esModule","d","a","definition","o","defineProperty","enumerable","f","e","chunkId","Promise","all","reduce","promises","u","miniCssF","g","globalThis","this","Function","window","obj","prop","prototype","hasOwnProperty","call","p","installedChunks","importScripts","chunkLoadingGlobal","self","parentChunkLoadingFunction","bind","moreModules","runtime","pop","next"],"sourceRoot":""}