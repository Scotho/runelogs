{"version":3,"file":"static/js/220.86e9a12c.chunk.js","mappings":"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","sources":["models/LogLine.ts","HitsplatNames.ts","utils/utils.ts","utils/LogSplitter.ts","utils/FileParser.ts","components/FileParserWorker.ts"],"sourcesContent":["import {BoostedLevels} from \"./BoostedLevels\";\n\nexport enum LogTypes {\n    LOG_VERSION = 'Log Version',\n    LOGGED_IN_PLAYER = 'Logged In Player',\n    BOOSTED_LEVELS = 'Boosted Levels',\n    PLAYER_EQUIPMENT = 'Player Equipment',\n    DEATH = 'Death',\n    TARGET_CHANGE = 'Target Change',\n    DAMAGE = 'Damage'\n}\n\nexport interface BaseLog {\n    date: string;\n    time: string;\n    timezone: string;\n    fightTime?: string;\n}\n\nexport interface LogVersionLog extends BaseLog {\n    type: LogTypes.LOG_VERSION;\n    logVersion: string;\n}\n\n\nexport interface LoggedInPlayerLog extends BaseLog {\n    type: LogTypes.LOGGED_IN_PLAYER;\n    loggedInPlayer: string;\n}\n\nexport interface BoostedLevelsLog extends BaseLog {\n    type: LogTypes.BOOSTED_LEVELS;\n    boostedLevels: BoostedLevels;\n}\n\nexport interface PlayerEquipmentLog extends BaseLog {\n    type: LogTypes.PLAYER_EQUIPMENT;\n    playerEquipment: string[];\n}\n\nexport interface DeathLog extends BaseLog {\n    type: LogTypes.DEATH;\n    target: string;\n}\n\nexport interface TargetChangeLog extends BaseLog {\n    type: LogTypes.TARGET_CHANGE;\n    source: string;\n    target: string;\n}\n\nexport interface DamageLog extends BaseLog {\n    type: LogTypes.DAMAGE;\n    target: string;\n    hitsplatName: string;\n    damageAmount: number;\n}\n\nexport type LogLine =\n    LogVersionLog\n    | LoggedInPlayerLog\n    | BoostedLevelsLog\n    | PlayerEquipmentLog\n    | DeathLog\n    | TargetChangeLog\n    | DamageLog;\n\nexport function filterByType<T extends LogLine['type']>(logs: LogLine[], type: T): Extract<LogLine, { type: T }>[] {\n    return logs.filter(log => log.type === type) as Extract<LogLine, { type: T }>[];\n}\n\n","export enum HitsplatNames {\n    POISON = 2,\n    DISEASE = 4,\n    VENOM = 5,\n    HEAL = 6,\n    BLOCK_ME = 12,\n    BLOCK_OTHER = 13,\n    DAMAGE_ME = 16,\n    DAMAGE_OTHER = 17,\n    DAMAGE_ME_CYAN = 18,\n    DAMAGE_OTHER_CYAN = 19,\n    DAMAGE_ME_ORANGE = 20,\n    DAMAGE_OTHER_ORANGE = 21,\n    DAMAGE_ME_YELLOW = 22,\n    DAMAGE_OTHER_YELLOW = 23,\n    DAMAGE_ME_WHITE = 24,\n    DAMAGE_OTHER_WHITE = 25,\n    DAMAGE_MAX_ME = 43,\n    DAMAGE_MAX_ME_CYAN = 44,\n    DAMAGE_MAX_ME_ORANGE = 45,\n    DAMAGE_MAX_ME_YELLOW = 46,\n    DAMAGE_MAX_ME_WHITE = 47,\n    SPLASH_ME = 69,\n}\n\nexport enum DamageMeHitsplats {\n    BLOCK_ME = HitsplatNames.BLOCK_ME,\n    DAMAGE_ME = HitsplatNames.DAMAGE_ME,\n    DAMAGE_ME_CYAN = HitsplatNames.DAMAGE_ME_CYAN,\n    DAMAGE_ME_ORANGE = HitsplatNames.DAMAGE_ME_ORANGE,\n    DAMAGE_ME_YELLOW = HitsplatNames.DAMAGE_ME_YELLOW,\n    DAMAGE_ME_WHITE = HitsplatNames.DAMAGE_ME_WHITE,\n    SPLASH_ME = HitsplatNames.SPLASH_ME,\n}\n\nexport enum DamageMaxMeHitsplats {\n    DAMAGE_MAX_ME = HitsplatNames.DAMAGE_MAX_ME,\n    DAMAGE_MAX_ME_CYAN = HitsplatNames.DAMAGE_MAX_ME_CYAN,\n    DAMAGE_MAX_ME_ORANGE = HitsplatNames.DAMAGE_MAX_ME_ORANGE,\n    DAMAGE_MAX_ME_YELLOW = HitsplatNames.DAMAGE_MAX_ME_YELLOW,\n    DAMAGE_MAX_ME_WHITE = HitsplatNames.DAMAGE_MAX_ME_WHITE,\n}\n\nexport enum DamageOtherHitsplats {\n    BLOCK_OTHER = HitsplatNames.BLOCK_OTHER,\n    DAMAGE_OTHER = HitsplatNames.DAMAGE_OTHER,\n    DAMAGE_OTHER_CYAN = HitsplatNames.DAMAGE_OTHER_CYAN,\n    DAMAGE_OTHER_ORANGE = HitsplatNames.DAMAGE_OTHER_ORANGE,\n    DAMAGE_OTHER_YELLOW = HitsplatNames.DAMAGE_OTHER_YELLOW,\n    DAMAGE_OTHER_WHITE = HitsplatNames.DAMAGE_OTHER_WHITE,\n}\n","import {Fight} from \"../models/Fight\";\nimport {LogLine, LogTypes} from \"../models/LogLine\";\n\nexport function getFightDuration(selectedLog: Fight) {\n    const fightDurationMilliseconds = calculateFightDuration(selectedLog!);\n    const duration = new Date(Date.UTC(0, 0, 0, 0, 0, 0, fightDurationMilliseconds));\n    const minutes = duration.getUTCMinutes();\n    const seconds = duration.getUTCSeconds();\n    const milliseconds = duration.getUTCMilliseconds();\n\n    const formattedDuration = `${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}.${milliseconds}`;\n    return formattedDuration;\n}\n\nconst calculateFightDuration = (fight: Fight) => {\n    if (fight.data.length === 0) {\n        return 0;\n    }\n\n    const startTime = convertTimeToMillis(fight.firstLine.time);\n    const endTime = convertTimeToMillis(fight.lastLine.time);\n\n    return endTime - startTime;\n};\n\nexport function calculateAccuracy(fight: Fight) {\n    const hitsplatsCount = fight.data.filter(log => log.type === LogTypes.DAMAGE).length;\n    const successfulHitsplatsCount = fight.data.filter(log => log.type === LogTypes.DAMAGE && (log as LogLine & {\n        type: LogTypes.DAMAGE\n    }).damageAmount > 0).length;\n    const accuracyPercentage = hitsplatsCount > 0 ? (successfulHitsplatsCount / hitsplatsCount) * 100 : 0;\n    return accuracyPercentage;\n}\n\nexport const convertTimeToMillis = (time: string): number => {\n    const [hours, minutes, seconds] = time.split(':').map(Number);\n    const milliseconds = hours * 3600000 + minutes * 60000 + seconds * 1000;\n    return milliseconds;\n};\n\nexport function convertMillisToTime(duration: number): string {\n    const milliseconds = Math.floor(duration % 1000);\n    let seconds: any = Math.floor((duration / 1000) % 60);\n    let minutes: any = Math.floor((duration / (1000 * 60)) % 60);\n    let hours: any = Math.floor((duration / (1000 * 60 * 60)) % 24);\n\n    hours = (hours < 10) ? \"0\" + hours : hours;\n    minutes = (minutes < 10) ? \"0\" + minutes : minutes;\n    seconds = (seconds < 10) ? \"0\" + seconds : seconds;\n\n    const formattedMilliseconds = (milliseconds < 10) ? \"00\" + milliseconds : (milliseconds < 100) ? \"0\" + milliseconds : milliseconds;\n\n    return hours + \":\" + minutes + \":\" + seconds + \".\" + formattedMilliseconds;\n}","import {DamageLog, LogLine, LogTypes} from \"../models/LogLine\";\nimport {DamageMaxMeHitsplats, DamageMeHitsplats} from \"../HitsplatNames\";\nimport {Fight} from \"../models/Fight\";\nimport {BoostedLevels} from \"../models/BoostedLevels\";\nimport {convertMillisToTime, convertTimeToMillis} from \"./utils\";\n\n\nconst BOSS_NAMES = [\n    \"Scurrius\",\n    \"Kree'arra\",\n    \"Commander Zilyana\",\n    \"General Graardor\",\n    \"K'ril Tsutsaroth\",\n    \"Nex\",\n    \"Kalphite Queen\",\n    \"Sarachnis\",\n    \"Scorpia\",\n    \"Abyssal Sire\"\n];\n\n/**\n * If it is the logged in player that dealt/attempted the damage\n */\nfunction playerAttemptsDamage(log: DamageLog) {\n    return Object.values(DamageMeHitsplats).includes(log.hitsplatName!) ||\n        Object.values(DamageMaxMeHitsplats).includes(log.hitsplatName!) ||\n        log.hitsplatName === 'BLOCK_ME';\n}\n\nexport function logSplitter(fightData: LogLine[], progressCallback?: (progress: number) => void): Fight[] {\n    const totalLines = fightData.length;\n    let parsedLines = 0;\n\n    const fights: Fight[] = [];\n    let currentFight: Fight | null = null;\n    let player: string = \"\"; //todo support multiple players\n    let lastDamage: { time: string, index: number } | null = null;\n    let boostedLevels: BoostedLevels | undefined;\n    let playerEquipment: string[] | undefined;\n    let fightStartTime: number = 0;\n\n    for (const logLine of fightData) {\n        if (logLine.type === LogTypes.LOGGED_IN_PLAYER) {\n            player = logLine.loggedInPlayer;\n        }\n\n        if (logLine.type === LogTypes.BOOSTED_LEVELS) {\n            boostedLevels = logLine.boostedLevels;\n        }\n\n        if (logLine.type === LogTypes.PLAYER_EQUIPMENT) {\n            playerEquipment = logLine.playerEquipment;\n        }\n\n        // If there's a gap of over 60 seconds end the current fight\n        if (currentFight && lastDamage && convertTimeToMillis(logLine.time) - convertTimeToMillis(lastDamage.time) > 60000) {\n            // eslint-disable-next-line no-loop-func\n            currentFight.data = currentFight.data.filter((log, index) => index <= lastDamage!.index);\n            currentFight.name += \" - Incomplete\";\n            currentFight.lastLine = currentFight.data[currentFight.data.length - 1];\n            fights.push(currentFight);\n            currentFight = null;\n            lastDamage = null;\n        }\n\n        // If the current fight is null, start a new fight\n        if (!currentFight && logLine.type === LogTypes.DAMAGE && playerAttemptsDamage(logLine) && logLine.target !== player) {\n            fightStartTime = convertTimeToMillis(logLine.time);\n            logLine.fightTime = convertMillisToTime(0);\n\n            const initialData: LogLine[] = [];\n\n            // Include current boosted levels at the beginning of the fight\n            if (boostedLevels) {\n                initialData.push({\n                    type: LogTypes.BOOSTED_LEVELS,\n                    date: logLine.date,\n                    time: logLine.time,\n                    timezone: logLine.timezone,\n                    boostedLevels: boostedLevels,\n                    fightTime: convertMillisToTime(0)\n                });\n            }\n\n            // Include current player equipment at the beginning of the fight\n            if (playerEquipment) {\n                initialData.push({\n                    type: LogTypes.PLAYER_EQUIPMENT,\n                    date: logLine.date,\n                    time: logLine.time,\n                    timezone: logLine.timezone,\n                    playerEquipment: playerEquipment,\n                    fightTime: convertMillisToTime(0)\n                });\n            }\n\n            currentFight = {\n                name: logLine.target,\n                enemies: [logLine.target],\n                data: [\n                    ...initialData,\n                    logLine\n                ],\n                loggedInPlayer: player,\n                firstLine: logLine,\n                lastLine: logLine\n            };\n        } else if (currentFight) {\n            // Rename the fight if we encounter a boss in the middle of it\n            if (\"target\" in logLine && BOSS_NAMES.includes(logLine.target!) && currentFight.name !== logLine.target) {\n                currentFight.name = logLine.target!;\n            }\n            // Add target to list of enemies\n            if (logLine.type === LogTypes.DAMAGE && playerAttemptsDamage(logLine) && logLine.target !== player && !currentFight.enemies.includes(logLine.target!)) {\n                currentFight.enemies.push(logLine.target!);\n            }\n\n            // Subtract the start time from the log's timestamp to get the relative time within the fight\n            const logTimestamp = convertTimeToMillis(logLine.time);\n            logLine.fightTime = convertMillisToTime(logTimestamp - fightStartTime);\n\n            currentFight.data.push(logLine);\n        }\n\n        if (currentFight && logLine.type === LogTypes.DAMAGE && playerAttemptsDamage(logLine)) {\n            lastDamage = {\n                time: logLine.time,\n                index: currentFight.data.length - 1\n            };\n        }\n\n        if (logLine.type === LogTypes.DEATH && logLine.target) {\n            // If the fight name dies, end the current fight\n            if (currentFight && (logLine.target === currentFight.name || logLine.target === currentFight.loggedInPlayer)) {\n                currentFight.lastLine = logLine;\n                fights.push(currentFight);\n                currentFight = null;\n            }\n        }\n\n        parsedLines++;\n        if (progressCallback && parsedLines % 200 === 0) {\n            const progress = 50 + (parsedLines / totalLines) * 50;\n            progressCallback(progress);\n        }\n    }\n\n    // If we reach the end of the logs, end the current fight\n    if (currentFight) {\n        currentFight.lastLine = currentFight.data[currentFight.data.length - 1];\n        fights.push(currentFight);\n    }\n\n    // Filter out fights with no damage from us\n    return fights.filter((fight) => fight.data.some((logLine) =>\n        logLine.type === LogTypes.DAMAGE && playerAttemptsDamage(logLine)\n    ));\n}\n","import {logSplitter} from \"./LogSplitter\";\nimport {Fight} from \"../models/Fight\";\nimport {LogLine, LogTypes} from \"../models/LogLine\";\n\nexport const parseLogLine = (logLine: string): LogLine | null => {\n    const DATE_PATTERN = '\\\\d{2}-\\\\d{2}-\\\\d{4}';\n    const TIME_PATTERN = '\\\\d{2}:\\\\d{2}:\\\\d{2}\\\\.\\\\d{3}';\n    const TIMEZONE_PATTERN = '\\\\w+';\n    const ANYTHING_PATTERN = '.*';\n    const ANYTHING_BUT_TAB_PATTERN = '[^\\\\t]*';\n\n    const pattern = new RegExp(`^(${DATE_PATTERN}) (${TIME_PATTERN}) (${TIMEZONE_PATTERN})\\t(${ANYTHING_PATTERN})`);\n\n    let match = logLine.match(pattern);\n\n    if (!match) {\n        console.error('Invalid log line format:', logLine);\n        return null;\n    }\n    const [, date, time, timezone, action] = match;\n\n\n    const logVersionPattern = new RegExp(`Log Version (${ANYTHING_PATTERN})`)\n    match = action.match(logVersionPattern);\n    if (match) {\n        const [, logVersion] = match;\n        console.log(`Log Version ${logVersion}`);\n        return {\n            type: LogTypes.LOG_VERSION,\n            date,\n            time,\n            timezone,\n            logVersion\n        };\n    }\n    const loggedInPlayerPattern = new RegExp(`Logged in player is (${ANYTHING_PATTERN})`)\n    match = action.match(loggedInPlayerPattern);\n    if (match) {\n        const [, loggedInPlayer] = match;\n        return {\n            type: LogTypes.LOGGED_IN_PLAYER,\n            date,\n            time,\n            timezone,\n            loggedInPlayer\n        };\n    }\n\n    const boostedLevelsPattern = new RegExp(`Boosted levels are \\\\[(\\\\d+), (\\\\d+), (\\\\d+), (\\\\d+), (\\\\d+), (\\\\d+), (\\\\d+)\\\\]`);\n    match = action.match(boostedLevelsPattern);\n    if (match) {\n        const [, attack, strength, defence, ranged, magic, hitpoints, prayer] = match.map(Number);\n\n        return {\n            type: LogTypes.BOOSTED_LEVELS,\n            date,\n            time,\n            timezone,\n            boostedLevels: {\n                attack,\n                strength,\n                defence,\n                ranged,\n                magic,\n                hitpoints,\n                prayer\n            }\n        };\n    }\n\n    const playerEquipmentPattern = new RegExp(`Player equipment is (${ANYTHING_PATTERN})`)\n    match = action.match(playerEquipmentPattern);\n    if (match) {\n        const [, equpimentString] = match;\n        const playerEquipment: string[] = JSON.parse(equpimentString).map((item: number) => item.toString());\n        return {\n            type: LogTypes.PLAYER_EQUIPMENT,\n            date,\n            time,\n            timezone,\n            playerEquipment\n        };\n    }\n\n    const diesPattern = new RegExp(`^(${ANYTHING_PATTERN}) dies`)\n    match = action.match(diesPattern);\n    if (match) {\n        const [, target] = match;\n        return {\n            type: LogTypes.DEATH,\n            date,\n            time,\n            timezone,\n            target,\n        };\n    }\n\n    const changedTargetPattern = new RegExp(`^(${ANYTHING_PATTERN}) changes target to (${ANYTHING_PATTERN})`)\n    match = action.match(changedTargetPattern);\n    if (match) {\n        const [, source, target] = match;\n        return {\n            type: LogTypes.TARGET_CHANGE,\n            date,\n            time,\n            timezone,\n            source,\n            target\n        };\n    }\n\n\n    const defaultPattern = new RegExp(`^(${ANYTHING_BUT_TAB_PATTERN})\\t(${ANYTHING_BUT_TAB_PATTERN})\\t(${ANYTHING_BUT_TAB_PATTERN})`);\n\n    match = action.match(defaultPattern);\n    if (!match) {\n        console.error('Invalid log line format:', logLine);\n        return null;\n    }\n    const [, target, hitsplatName, damageAmount] = match;\n\n    return {\n        type: LogTypes.DAMAGE,\n        date,\n        time,\n        timezone,\n        target,\n        hitsplatName,\n        damageAmount: parseInt(damageAmount, 10),\n    };\n};\n\nexport function parseFileContent(fileContent: string, progressCallback: (progress: number) => void): Fight[] | null {\n    try {\n        const lines = fileContent.split('\\n');\n        let parsedLines = 0;\n        let fightData: LogLine[] = [];\n\n        for (const line of lines) {\n            const logLine = parseLogLine(line.trim());\n\n            if (logLine) {\n                fightData.push(logLine);\n            }\n\n            parsedLines++;\n            if (progressCallback && parsedLines % 200 === 0) {\n                const progress = (parsedLines / lines.length) * 50;\n                progressCallback(progress);\n            }\n        }\n\n        let fights: Fight[] = logSplitter(fightData, progressCallback);\n\n        return fights;\n    } catch (error) {\n        console.error('Error parsing file content:', error);\n        return null;\n    }\n}\n\n","import {Fight} from \"../models/Fight\";\nimport {parseFileContent} from \"../utils/FileParser\";\n\nlet parseResults: Fight[] | null = null;\n\nfunction parseFileWithProgress(fileContent: string) {\n    parseResults = parseFileContent(fileContent, (progress) => {\n        postMessage({type: 'progress', progress});\n    });\n\n    const fightNames = parseResults?.map(fight => fight.name) || [];\n    const parseResultMessage = {\n        fightNames,\n        firstResult: parseResults![0],\n    }\n    postMessage({type: 'parseResult', parseResultMessage});\n}\n\nfunction getSpecificItem(index: number) {\n    if (parseResults && index >= 0 && index < parseResults.length) {\n        return parseResults[index];\n    }\n    return null;\n}\n\nonmessage = (event) => {\n    const {type, fileContent, index} = event.data;\n    if (type === 'parse') {\n        parseFileWithProgress(fileContent);\n    } else if (type === 'getItem') {\n        const item = getSpecificItem(index);\n        postMessage({type: 'item', item});\n    }\n};\n"],"names":["LogTypes","DamageMeHitsplats","DamageMaxMeHitsplats","convertTimeToMillis","time","hours","minutes","seconds","split","map","Number","convertMillisToTime","duration","milliseconds","Math","floor","BOSS_NAMES","playerAttemptsDamage","log","Object","values","includes","hitsplatName","parseLogLine","logLine","ANYTHING_PATTERN","ANYTHING_BUT_TAB_PATTERN","pattern","RegExp","concat","match","console","error","date","timezone","action","logVersionPattern","logVersion","type","LOG_VERSION","loggedInPlayerPattern","loggedInPlayer","LOGGED_IN_PLAYER","boostedLevelsPattern","attack","strength","defence","ranged","magic","hitpoints","prayer","BOOSTED_LEVELS","boostedLevels","playerEquipmentPattern","equpimentString","playerEquipment","JSON","parse","item","toString","PLAYER_EQUIPMENT","diesPattern","target","DEATH","changedTargetPattern","source","TARGET_CHANGE","defaultPattern","damageAmount","DAMAGE","parseInt","parseFileContent","fileContent","progressCallback","lines","parsedLines","fightData","line","trim","push","length","fights","totalLines","currentFight","player","lastDamage","fightStartTime","data","filter","index","name","lastLine","fightTime","initialData","enemies","firstLine","logTimestamp","fight","some","logSplitter","parseResults","onmessage","event","_parseResults","progress","postMessage","parseResultMessage","fightNames","firstResult","parseFileWithProgress","getSpecificItem"],"sourceRoot":""}