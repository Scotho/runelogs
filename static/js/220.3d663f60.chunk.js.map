{"version":3,"file":"static/js/220.3d663f60.chunk.js","mappings":"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","sources":["models/LogLine.ts","HitsplatNames.ts","utils/utils.ts","utils/LogSplitter.ts","utils/FileParser.ts","components/FileParserWorker.ts"],"sourcesContent":["import {BoostedLevels} from \"./BoostedLevels\";\n\nexport enum LogTypes {\n    LOG_VERSION = 'Log Version',\n    LOGGED_IN_PLAYER = 'Logged In Player',\n    BOOSTED_LEVELS = 'Boosted Levels',\n    PLAYER_EQUIPMENT = 'Player Equipment',\n    DEATH = 'Death',\n    TARGET_CHANGE = 'Target Change',\n    DAMAGE = 'Damage'\n}\n\nexport interface BaseLog {\n    date: string;\n    time: string;\n    timezone: string;\n}\n\nexport interface LogVersionLog extends BaseLog {\n    type: LogTypes.LOG_VERSION;\n    logVersion: string;\n}\n\n\nexport interface LoggedInPlayerLog extends BaseLog {\n    type: LogTypes.LOGGED_IN_PLAYER;\n    loggedInPlayer: string;\n}\n\nexport interface BoostedLevelsLog extends BaseLog {\n    type: LogTypes.BOOSTED_LEVELS;\n    boostedLevels: BoostedLevels;\n}\n\nexport interface PlayerEquipmentLog extends BaseLog {\n    type: LogTypes.PLAYER_EQUIPMENT;\n    playerEquipment: string[];\n}\n\nexport interface DeathLog extends BaseLog {\n    type: LogTypes.DEATH;\n    target: string;\n}\n\nexport interface TargetChangeLog extends BaseLog {\n    type: LogTypes.TARGET_CHANGE;\n    source: string;\n    target: string;\n}\n\nexport interface DamageLog extends BaseLog {\n    type: LogTypes.DAMAGE;\n    target: string;\n    hitsplatName: string;\n    damageAmount: number;\n}\n\nexport type LogLine =\n    LogVersionLog\n    | LoggedInPlayerLog\n    | BoostedLevelsLog\n    | PlayerEquipmentLog\n    | DeathLog\n    | TargetChangeLog\n    | DamageLog;\n\nexport function filterByType<T extends LogLine['type']>(logs: LogLine[], type: T): Extract<LogLine, { type: T }>[] {\n    return logs.filter(log => log.type === type) as Extract<LogLine, { type: T }>[];\n}\n\n","export enum HitsplatNames {\n    POISON = 2,\n    DISEASE = 4,\n    VENOM = 5,\n    HEAL = 6,\n    BLOCK_ME = 12,\n    BLOCK_OTHER = 13,\n    DAMAGE_ME = 16,\n    DAMAGE_OTHER = 17,\n    DAMAGE_ME_CYAN = 18,\n    DAMAGE_OTHER_CYAN = 19,\n    DAMAGE_ME_ORANGE = 20,\n    DAMAGE_OTHER_ORANGE = 21,\n    DAMAGE_ME_YELLOW = 22,\n    DAMAGE_OTHER_YELLOW = 23,\n    DAMAGE_ME_WHITE = 24,\n    DAMAGE_OTHER_WHITE = 25,\n    DAMAGE_MAX_ME = 43,\n    DAMAGE_MAX_ME_CYAN = 44,\n    DAMAGE_MAX_ME_ORANGE = 45,\n    DAMAGE_MAX_ME_YELLOW = 46,\n    DAMAGE_MAX_ME_WHITE = 47,\n    SPLASH_ME = 69,\n}\n\nexport enum DamageMeHitsplats {\n    BLOCK_ME = HitsplatNames.BLOCK_ME,\n    DAMAGE_ME = HitsplatNames.DAMAGE_ME,\n    DAMAGE_ME_CYAN = HitsplatNames.DAMAGE_ME_CYAN,\n    DAMAGE_ME_ORANGE = HitsplatNames.DAMAGE_ME_ORANGE,\n    DAMAGE_ME_YELLOW = HitsplatNames.DAMAGE_ME_YELLOW,\n    DAMAGE_ME_WHITE = HitsplatNames.DAMAGE_ME_WHITE,\n    SPLASH_ME = HitsplatNames.SPLASH_ME,\n}\n\nexport enum DamageMaxMeHitsplats {\n    DAMAGE_MAX_ME = HitsplatNames.DAMAGE_MAX_ME,\n    DAMAGE_MAX_ME_CYAN = HitsplatNames.DAMAGE_MAX_ME_CYAN,\n    DAMAGE_MAX_ME_ORANGE = HitsplatNames.DAMAGE_MAX_ME_ORANGE,\n    DAMAGE_MAX_ME_YELLOW = HitsplatNames.DAMAGE_MAX_ME_YELLOW,\n    DAMAGE_MAX_ME_WHITE = HitsplatNames.DAMAGE_MAX_ME_WHITE,\n}\n\nexport enum DamageOtherHitsplats {\n    BLOCK_OTHER = HitsplatNames.BLOCK_OTHER,\n    DAMAGE_OTHER = HitsplatNames.DAMAGE_OTHER,\n    DAMAGE_OTHER_CYAN = HitsplatNames.DAMAGE_OTHER_CYAN,\n    DAMAGE_OTHER_ORANGE = HitsplatNames.DAMAGE_OTHER_ORANGE,\n    DAMAGE_OTHER_YELLOW = HitsplatNames.DAMAGE_OTHER_YELLOW,\n    DAMAGE_OTHER_WHITE = HitsplatNames.DAMAGE_OTHER_WHITE,\n}\n","import {Fight} from \"../models/Fight\";\nimport {LogLine} from \"../models/LogLine\";\n\nexport function getFightDuration(selectedLog: Fight) {\n    const fightDurationMilliseconds = calculateFightDuration(selectedLog!.data);\n    const duration = new Date(Date.UTC(0, 0, 0, 0, 0, 0, fightDurationMilliseconds));\n    const minutes = duration.getUTCMinutes();\n    const seconds = duration.getUTCSeconds();\n    const milliseconds = duration.getUTCMilliseconds();\n\n    const formattedDuration = `${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}.${milliseconds}`;\n    return formattedDuration;\n}\n\nconst calculateFightDuration = (logs: LogLine[]) => {\n    if (logs.length === 0) {\n        return 0;\n    }\n\n    const startTime = convertTimeToMillis(logs[0].time);\n    const endTime = convertTimeToMillis(logs[logs.length - 1].time);\n\n    return endTime - startTime;\n};\n\nexport const convertTimeToMillis = (time: string): number => {\n    const [hours, minutes, seconds] = time.split(':').map(Number);\n    const milliseconds = hours * 3600000 + minutes * 60000 + seconds * 1000;\n    return milliseconds;\n};","import {DamageLog, LogLine, LogTypes} from \"../models/LogLine\";\nimport {DamageMaxMeHitsplats, DamageMeHitsplats} from \"../HitsplatNames\";\nimport {Fight} from \"../models/Fight\";\nimport {BoostedLevels} from \"../models/BoostedLevels\";\nimport {convertTimeToMillis} from \"./utils\";\n\n\nconst BOSS_NAMES = [\n    \"Scurrius\",\n    \"Kree'arra\",\n    \"Commander Zilyana\",\n    \"General Graardor\",\n    \"K'ril Tsutsaroth\",\n    \"Nex\",\n    \"Kalphite Queen\",\n    \"Sarachnis\",\n    \"Scorpia\",\n    \"Abyssal Sire\"\n];\n\n/**\n * If it is the logged in player that dealt/attempted the damage\n */\nfunction playerAttemptsDamage(log: DamageLog) {\n    return Object.values(DamageMeHitsplats).includes(log.hitsplatName!) ||\n        Object.values(DamageMaxMeHitsplats).includes(log.hitsplatName!) ||\n        log.hitsplatName === 'BLOCK_ME';\n}\n\nexport function logSplitter(fightData: LogLine[], progressCallback?: (progress: number) => void): Fight[] {\n    const totalLines = fightData.length;\n    let parsedLines = 0;\n\n    const fights: Fight[] = [];\n    let currentFight: Fight | null = null;\n    let player: string = \"\"; //todo support multiple players\n    let lastDamage: { time: string, index: number } | null = null;\n    let boostedLevels: BoostedLevels | undefined;\n    let playerEquipment: string[] | undefined;\n\n    for (const logLine of fightData) {\n        if (logLine.type === LogTypes.LOGGED_IN_PLAYER) {\n            player = logLine.loggedInPlayer;\n        }\n\n        if (logLine.type === LogTypes.BOOSTED_LEVELS) {\n            boostedLevels = logLine.boostedLevels;\n        }\n\n        if (logLine.type === LogTypes.PLAYER_EQUIPMENT) {\n            playerEquipment = logLine.playerEquipment;\n        }\n\n        // If there's a gap of over 60 seconds end the current fight\n        if (currentFight && lastDamage && convertTimeToMillis(logLine.time) - convertTimeToMillis(lastDamage.time) > 60000) {\n            // eslint-disable-next-line no-loop-func\n            currentFight.data = currentFight.data.filter((log, index) => index <= lastDamage!.index);\n            currentFight.name += \" - Incomplete\";\n            currentFight.lastLine = currentFight.data[currentFight.data.length - 1];\n            fights.push(currentFight);\n            currentFight = null;\n            lastDamage = null;\n        }\n\n        // If the current fight is null, start a new fight\n        if (!currentFight && logLine.type === LogTypes.DAMAGE && playerAttemptsDamage(logLine) && logLine.target !== player) {\n            const initialData: LogLine[] = [];\n\n            // Include current boosted levels at the beginning of the fight\n            if (boostedLevels) {\n                initialData.push({\n                    type: LogTypes.BOOSTED_LEVELS,\n                    date: logLine.date,\n                    time: logLine.time,\n                    timezone: logLine.timezone,\n                    boostedLevels: boostedLevels\n                });\n            }\n\n            // Include current player equipment at the beginning of the fight\n            if (playerEquipment) {\n                initialData.push({\n                    type: LogTypes.PLAYER_EQUIPMENT,\n                    date: logLine.date,\n                    time: logLine.time,\n                    timezone: logLine.timezone,\n                    playerEquipment: playerEquipment\n                });\n            }\n\n            currentFight = {\n                name: logLine.target,\n                enemies: [logLine.target],\n                data: [\n                    ...initialData,\n                    logLine\n                ],\n                loggedInPlayer: player,\n                firstLine: logLine,\n                lastLine: undefined\n            };\n        } else if (currentFight) {\n            // Rename the fight if we encounter a boss in the middle of it\n            if (\"target\" in logLine && BOSS_NAMES.includes(logLine.target!) && currentFight.name !== logLine.target) {\n                currentFight.name = logLine.target!;\n            }\n            // Add target to list of enemies\n            if (logLine.type === LogTypes.DAMAGE && playerAttemptsDamage(logLine) && logLine.target !== player && !currentFight.enemies.includes(logLine.target!)) {\n                currentFight.enemies.push(logLine.target!);\n            }\n            currentFight.data.push(logLine);\n        }\n\n        if (currentFight && logLine.type === LogTypes.DAMAGE && playerAttemptsDamage(logLine)) {\n            lastDamage = {\n                time: logLine.time,\n                index: currentFight.data.length - 1\n            };\n        }\n\n        if (logLine.type === LogTypes.DEATH && logLine.target) {\n            // If the fight name dies, end the current fight\n            if (currentFight && (logLine.target === currentFight.name || logLine.target === currentFight.loggedInPlayer)) {\n                currentFight.lastLine = logLine;\n                fights.push(currentFight);\n                currentFight = null;\n            }\n        }\n\n        parsedLines++;\n        if (progressCallback && parsedLines % 200 === 0) {\n            const progress = 50 + (parsedLines / totalLines) * 50;\n            progressCallback(progress);\n        }\n    }\n\n    // If we reach the end of the logs, end the current fight\n    if (currentFight) {\n        currentFight.lastLine = currentFight.data[currentFight.data.length - 1];\n        fights.push(currentFight);\n    }\n\n    // Filter out fights with no damage from us\n    return fights.filter((fight) => fight.data.some((logLine) =>\n        logLine.type === LogTypes.DAMAGE && playerAttemptsDamage(logLine)\n    ));\n}\n","import {logSplitter} from \"./LogSplitter\";\nimport {Fight} from \"../models/Fight\";\nimport {LogLine, LogTypes} from \"../models/LogLine\";\n\nexport const parseLogLine = (logLine: string): LogLine | null => {\n    const DATE_PATTERN = '\\\\d{2}-\\\\d{2}-\\\\d{4}';\n    const TIME_PATTERN = '\\\\d{2}:\\\\d{2}:\\\\d{2}\\\\.\\\\d{3}';\n    const TIMEZONE_PATTERN = '\\\\w+';\n    const ANYTHING_PATTERN = '.*';\n    const ANYTHING_BUT_TAB_PATTERN = '[^\\\\t]*';\n\n    const pattern = new RegExp(`^(${DATE_PATTERN}) (${TIME_PATTERN}) (${TIMEZONE_PATTERN})\\t(${ANYTHING_PATTERN})`);\n\n    let match = logLine.match(pattern);\n\n    if (!match) {\n        console.error('Invalid log line format:', logLine);\n        return null;\n    }\n    const [, date, time, timezone, action] = match;\n\n\n    const logVersionPattern = new RegExp(`Log Version (${ANYTHING_PATTERN})`)\n    match = action.match(logVersionPattern);\n    if (match) {\n        const [, logVersion] = match;\n        console.log(`Log Version ${logVersion}`);\n        return {\n            type: LogTypes.LOG_VERSION,\n            date,\n            time,\n            timezone,\n            logVersion\n        };\n    }\n    const loggedInPlayerPattern = new RegExp(`Logged in player is (${ANYTHING_PATTERN})`)\n    match = action.match(loggedInPlayerPattern);\n    if (match) {\n        const [, loggedInPlayer] = match;\n        return {\n            type: LogTypes.LOGGED_IN_PLAYER,\n            date,\n            time,\n            timezone,\n            loggedInPlayer\n        };\n    }\n\n    const boostedLevelsPattern = new RegExp(`Boosted levels are \\\\[(\\\\d+), (\\\\d+), (\\\\d+), (\\\\d+), (\\\\d+), (\\\\d+), (\\\\d+)\\\\]`);\n    match = action.match(boostedLevelsPattern);\n    if (match) {\n        const [, attack, strength, defence, ranged, magic, hitpoints, prayer] = match.map(Number);\n\n        return {\n            type: LogTypes.BOOSTED_LEVELS,\n            date,\n            time,\n            timezone,\n            boostedLevels: {\n                attack,\n                strength,\n                defence,\n                ranged,\n                magic,\n                hitpoints,\n                prayer\n            }\n        };\n    }\n\n    const playerEquipmentPattern = new RegExp(`Player equipment is (${ANYTHING_PATTERN})`)\n    match = action.match(playerEquipmentPattern);\n    if (match) {\n        const [, equpimentString] = match;\n        const playerEquipment: string[] = JSON.parse(equpimentString).map((item: number) => item.toString());\n        return {\n            type: LogTypes.PLAYER_EQUIPMENT,\n            date,\n            time,\n            timezone,\n            playerEquipment\n        };\n    }\n\n    const diesPattern = new RegExp(`^(${ANYTHING_PATTERN}) dies`)\n    match = action.match(diesPattern);\n    if (match) {\n        const [, target] = match;\n        return {\n            type: LogTypes.DEATH,\n            date,\n            time,\n            timezone,\n            target,\n        };\n    }\n\n    const changedTargetPattern = new RegExp(`^(${ANYTHING_PATTERN}) changes target to (${ANYTHING_PATTERN})`)\n    match = action.match(changedTargetPattern);\n    if (match) {\n        const [, source, target] = match;\n        return {\n            type: LogTypes.TARGET_CHANGE,\n            date,\n            time,\n            timezone,\n            source,\n            target\n        };\n    }\n\n\n    const defaultPattern = new RegExp(`^(${ANYTHING_BUT_TAB_PATTERN})\\t(${ANYTHING_BUT_TAB_PATTERN})\\t(${ANYTHING_BUT_TAB_PATTERN})`);\n\n    match = action.match(defaultPattern);\n    if (!match) {\n        console.error('Invalid log line format:', logLine);\n        return null;\n    }\n    const [, target, hitsplatName, damageAmount] = match;\n\n    return {\n        type: LogTypes.DAMAGE,\n        date,\n        time,\n        timezone,\n        target,\n        hitsplatName,\n        damageAmount: parseInt(damageAmount, 10),\n    };\n};\n\nexport function parseFileContent(fileContent: string, progressCallback: (progress: number) => void): Fight[] | null {\n    try {\n        const lines = fileContent.split('\\n');\n        let parsedLines = 0;\n        let fightData: LogLine[] = [];\n\n        for (const line of lines) {\n            const logLine = parseLogLine(line.trim());\n\n            if (logLine) {\n                fightData.push(logLine);\n            }\n\n            parsedLines++;\n            if (progressCallback && parsedLines % 200 === 0) {\n                const progress = (parsedLines / lines.length) * 50;\n                progressCallback(progress);\n            }\n        }\n\n        let fights: Fight[] = logSplitter(fightData, progressCallback);\n\n        return fights;\n    } catch (error) {\n        console.error('Error parsing file content:', error);\n        return null;\n    }\n}\n\n","import {Fight} from \"../models/Fight\";\nimport {parseFileContent} from \"../utils/FileParser\";\n\nlet parseResults: Fight[] | null = null;\n\nfunction parseFileWithProgress(fileContent: string) {\n    parseResults = parseFileContent(fileContent, (progress) => {\n        postMessage({type: 'progress', progress});\n    });\n\n    const fightNames = parseResults?.map(fight => fight.name) || [];\n    const parseResultMessage = {\n        fightNames,\n        firstResult: parseResults![0],\n    }\n    postMessage({type: 'parseResult', parseResultMessage});\n}\n\nfunction getSpecificItem(index: number) {\n    if (parseResults && index >= 0 && index < parseResults.length) {\n        return parseResults[index];\n    }\n    return null;\n}\n\nonmessage = (event) => {\n    const {type, fileContent, index} = event.data;\n    if (type === 'parse') {\n        parseFileWithProgress(fileContent);\n    } else if (type === 'getItem') {\n        const item = getSpecificItem(index);\n        postMessage({type: 'item', item});\n    }\n};\n"],"names":["LogTypes","DamageMeHitsplats","DamageMaxMeHitsplats","convertTimeToMillis","time","hours","minutes","seconds","split","map","Number","BOSS_NAMES","playerAttemptsDamage","log","Object","values","includes","hitsplatName","parseLogLine","logLine","ANYTHING_PATTERN","ANYTHING_BUT_TAB_PATTERN","pattern","RegExp","concat","match","console","error","date","timezone","action","logVersionPattern","logVersion","type","LOG_VERSION","loggedInPlayerPattern","loggedInPlayer","LOGGED_IN_PLAYER","boostedLevelsPattern","attack","strength","defence","ranged","magic","hitpoints","prayer","BOOSTED_LEVELS","boostedLevels","playerEquipmentPattern","equpimentString","playerEquipment","JSON","parse","item","toString","PLAYER_EQUIPMENT","diesPattern","target","DEATH","changedTargetPattern","source","TARGET_CHANGE","defaultPattern","damageAmount","DAMAGE","parseInt","parseFileContent","fileContent","progressCallback","lines","parsedLines","fightData","line","trim","push","length","fights","totalLines","currentFight","player","lastDamage","data","filter","index","name","lastLine","initialData","enemies","firstLine","undefined","fight","some","logSplitter","parseResults","onmessage","event","_parseResults","progress","postMessage","parseResultMessage","fightNames","firstResult","parseFileWithProgress","getSpecificItem"],"sourceRoot":""}